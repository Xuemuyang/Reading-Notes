# 前端性能

## 初探

> 任何一个用户端的产品，都要把这六个过程滴水不漏的考虑到自己的性能优化方案内，反复权衡，从而打磨出用户满意的速度。

1. DNS 解析
1. TCP 连接
1. HTTP 请求抛出
1. 服务端处理请求
1. HTTP 响应返回
1. 浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户

![思维导图](./images/performance/index.png)

## 网络优化

### Webpack性能调优与Gzip原理

前端在DNS与TCP这一层的努力非常有限，HTTP层的优化才是核心。

HTTP优化两个大方向：

- 减少请求次数
- 减少单次请求所花费的时间

#### Webpack

Webpack的优化瓶颈在两个方面：

- 构建时间
- 打包体积

1.不要让loader做太多事情

使用include或者exclude避免不必要的转译，还可以开启缓存，将转译结果缓存至文件系统。

2.第三方库的打包可以使用DLL

```js
const path = require('path')
const webpack = require('webpack')

module.exports = {
  entry: {
    // 依赖的库数组
    vendor: [
    'prop-types',
    'babel-polyfill',
    'react',
    'react-dom',
    'react-router-dom',
    ]
  },
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name].js',
    library: '[name]_[hash]',
  },
  plugins: [
    new webpack.DllPlugin({
    // DllPlugin的name属性需要和libary保持一致
    name: '[name]_[hash]',
    path: path.join(__dirname, 'dist', '[name]-manifest.json'),
    // context需要和webpack.config.js保持一致
    context: __dirname,
    }),
  ],
}...
```

3.happypack多进程

4.删除冗余代码

webpack基于ES6的模块系统Tree-Shaking

在Uglify的操作中可以传入很多选项

```js
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
  module.exports = {
    plugins: [
      new UglifyJsPlugin({
        // 允许并发
        parallel: true,
        // 开启缓存
        cache: true,
        compress: {
          // 删除所有的console语句
          drop_console: true,
          // 把使用多次的静态值自动定义为变量
          reduce_vars: true,
        },
        output: {
          // 不保留注释
          comment: false,
          // 使输出的代码尽可能紧凑
          beautify: false
        }
      })
    ]
  }...
```

#### Gzip

Gzip的内核是Deflate。

压缩原理的背后是在文本文件中找出一些重复出现的字符串，临时替换他们，从而使整个文件变小。根据这个原理，文本中代码的重复率越高，压缩的效率就越高，Gzip的收益也越大。

Webpack中Gzip压缩操作的存在，事实上是为了在构建过程中做掉一部分服务器的工作，为服务器分压。

### 图片优化-质量与性能的博弈

与其说在“优化”，不如说是在做“权衡”，我们的主要任务就是去寻求一个质量与性能之间的平衡点。

![缓存的选择](./images/performance/cache-choice.png)

#### 不同业务场景下的图片方案选型

在计算机中，像素用二进制数来表示，一个像素对应的二进制位数越多，可以表示的颜色种类就越多，成像效果越细腻，文件体积就越大。

一个二进制位表示两种颜色(0|1 对应 黑|白)，如果一个图片格式对应的二进制位有n个，那么它就可以呈现2^n种颜色。

##### JPEG/JPG

JPG的特点是有损压缩，当把体积压缩至原有体积的50%一下，任然可以保持住60%的品质。

JPG适用于呈现色彩吩咐的图片，JPG常用作大的背景图、轮播图或Banner图出现。

缺陷在于处理矢量图形和Logo等线条感较强、颜色对比强烈的图像时，认为压缩导致的图片模糊比较明显，且不支持透明。

##### PNG-8和PNG-24

8和24这里都是二进制位数，8位PNG支持256种颜色,24位的可以呈现约1600万种颜色。

考虑到PNG在处理线条和颜色对比度方面的优势，主要用来呈现小的Logo、颜色简单且对比强烈的图片或背景等。

比如某宝的Logo，较小的Logo(CSS Sprites)，颜色对比度较强的图片。

##### SVG

SVG文件体积小，压缩性强，图片可以无限放大且不失真。

##### Base64

base64作为CSS Sprites的补充而存在。

Base64编码后，图片大小会膨胀为源文件的4/3。

这是几条适用场景

- 图片的实际尺寸很小(大多不足2kb)
- 图片无法以sprites图片的形式与其它小图结合(sprites图片仍是主要的减少HTTP请求的途径，Base64是sprites的补充)
- 图片的更新频率非常低(不需要我们重复编码和修改文件内容，维护成本较低)

推荐使用webpack的url-loader进行Base64编码。

##### WebP

什么都好除了兼容性

```html
<img src="//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg_.webp" alt="手机app - 聚划算" class="app-icon">
```

在wdbp前面还有一个jpg的后缀，这里是降级方案。

##### 小结

做电商就是做图片...
