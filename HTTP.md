# HTTP

## 第1章 了解`Web`及网络基础

### 1.1 使用`HTTP`协议访问`Web`

`HTTP(HyperText Transfer Protocol)`超文本传输协议。

`Web`是建立在`HTTP`协议上通信的。

### 1.2 `HTTP`的诞生

`HTTP/0.9`

`HTTP`于1990年问世。那时并没有作为正式的标准被建立。

`HTTP/1.0`

1996年5月被公布，虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端。

`HTTP/1.1`

1997年1月公布，是目前主流的`HTTP`协议版本。

### 1.3 网络基础`TCP/IP`

计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。我们把这种规则称为协议(`protocol`)。

`TCP/IP`是在`IP`协议的通信过程中，使用到的协议族的统称。

#### `TCP/IP`的分层管理

`TCP/IP`协议族按层次分别分为以下4层：应用层、传输层、网络层和数据链路层。

1.应用层

应用层决定了向用户提供应用服务时的通信。

比如`FTP(File Transfer Protocol，文件传输协议)`和`DNS(Domain Name System，域名系统)`。

`HTTP`协议也处于该层。

2.传输层

传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。

传输层有两个性质不同的协议:`TCP(Transmission Control Protocol，传输控制协议)`和`UDP(User Data Protocol，用户数据报协议)`。

3.网络层(又名网络互联层)

网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。

与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输线路。

4.链路层(又名数据链路层，网络接口层)

用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、`NIC(Network Interface Card，网络适配器，即网卡)`，及光纤等物理课件部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。

![](./images/HTTP/1.png)

利用`TCP/IP`协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层往下走，接收端则从应用层往上走。

以`HTTP`举例来说明，首先作为发送端的客户端在应用层(`HTTP`协议)发出一个想看某个`Web`页面的`HTTP`请求。

为了传输方便，在传输层(`TCP`协议)把从应用层处收到的数据(`HTTP`请求报文)进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。

在网络层(`IP`协议)，增加作为通信目的地的`MAC`地址后转发给链路层。

接收端的服务器在链路层接受到数据，按序往上层发送，一直到应用层。

![](./images/HTTP/2.png)

发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。

### 与`HTTP`关系密切的协议：`IP`、`TCP`和`DNS`

#### 负责传输的`IP`协议

`IP`协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是`IP`地址和`MAC`地址(`Media Access Control Address`)。

`IP`间的通信依赖`MAC`地址，网络上通信的双方在同一局域网(`LAN`)内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的`MAC`地址来搜索下一个中转目标。这时会采用`ARP`协议(`Address Resolution Protocol`)。`ARP`是一种以解析地址的协议，根据通信方的`IP`地址就可以反查出对应的`MAC`地址。

无论哪台计算机、哪台网络设备，它们都无法全面掌握互联网中的细节。

#### 确保可靠性的`TCP`协议

按层次分，`TCP`位于传输层，提供可靠的字节流服务。

字节流服务(`Byte Stream Service`)是指，为了方便传输，将大块数据分割成以报文段(`segment`)为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。简而言之`TCP`协议为了更容易传送大数据才把数据分割，而且`TCP`协议能够确认数据最终是否送达到对方。

确保数据能到达目标。

为了准确无误将数据送达目标，`TCP`协议采用了三次握手(`three-way handshaking`)策略。用`TCP`协议把数据包送出去后，一定会向对方确认是否送达。握手过程中使用了`TCP`的标志---`SYN(synchronize)`和`ACK(acknowledgement)`。

![](./images/HTTP/3.png)

除了三次握手，`TCP`协议还有其他各种手段来保证通信的可靠性。

#### 负责域名解析的`DNS`服务

`DNS(Domain Name System)`服务是和`HTTP`协议一样位于应用层的协议。它提供域名到`IP`地址之间的解析服务。

计算机既可以被赋予`IP`地址，也可以被赋予主机名和域名。

`DNS`协议通过域名查找`IP`地址，或逆向从`IP`地址反查域名。

![](./images/HTTP/4.png)

### 1.7 `URI`和`URL`

`URI(Uniform Resource Identifier)`

`URI`用字符串标识某一互联网资源，`URL`表示资源的地点(互联网上所处的位置)。`URL`是`URI`的子集。

#### `URI`格式

绝对`URI`的格式

![](./images/HTTP/5.png)

协议方案名最后要附冒号

登录信息是可选项

服务器地址可以是`google.com`这种`DNS`可解析的名称，或是`192.168.1.1`这类`IPv4`地址名，还可以是`[0:0:0:0:0:0:0:1]`这样用方括号括起来的`IPv6`地址名。

端口号是可选项，用户省略则自动使用默认端口号。

## 第2章 简单的`HTTP`协议

请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。

应用`HTTP`协议时，必定是一端担任客户端角色，另一端担任服务器端角色。

`HTTP`协议规定，请求从客户端发出，服务器端响应该请求并返回。肯定是从客户端开始建立通信，服务器端在没有接收到请求之前不会发送响应。

请求报文是由请求方法、请求`URI`、协议版本、可选的请求首部字段和内容实体构成。

![](./images/HTTP/6.png)

接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。

![](./images/HTTP/7.png)

开头的`HTTP/1.1`表示服务器对应的`HTTP`版本。

`200 OK`表示请求的处理结果的状态码(`status code`)和原因短语(`reson-phrase`)。下一行显示了创建响应的日期时间，是首部字段(`header field`)内的一个属性。

之后的内容都称为资源实体的主体(`entity body`)。

![](./images/HTTP/8.png)

### `HTTP`是不保存状态的协议

`HTTP`是一种不保存状态，即无状态(`stateless`)协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在`HTTP`这个级别，协议对于发送过的请求或响应不做持久化处理。

`HTTP/1.1`虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了`Cookie`技术。有了`Cookie`再用`HTTP`协议通信，就可以管理状态了。

### 告知服务器意图的`HTTP`方法

`GET`:获取资源

`GET`方法用来请求访问已被`URI`识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回;如果是像`CGI`(Common Gateway Interface，通用网关接口)那样的程序，则返回经过执行后的输出结果。

![](./images/HTTP/9.png)

![](./images/HTTP/10.png)

`POST`:传输实体主体

![](./images/HTTP/11.png)

`PUT`:传输文件

鉴于`HTTP/1.1`的`PUT`方法自身不带验证机制，任何人都可以上传文件, 存在安全性问题，因此一般的`Web`网站不使用该方法。若配合`Web`应用程序的验证机制，或架构设计采用`REST`(REpresentational State Transfer，表征状态转移)标准的同类`Web`网站，就可能会开放使用`PUT`方法。

![](./images/HTTP/12.png)

`HEAD`:获取报文首部

`HEAD`方法和`GET`方法一样，只是不返回报文主体部分。用于确认`URI`的有效性及资源更新的日期时间等。

![](./images/HTTP/13.png)

`DELETE`:删除文件

`DELETE`方法用来删除文件，是与`PUT`相反的方法。`DELETE`方法按请求`URI`删除指定的资源。但是，`HTTP/1.1`的`DELETE`方法本身和`PUT`方法一样不带验证机制，所以一般的`Web`网站也不使用`DELETE`方法。当配合`Web`应用程序的验证机制，或遵守`REST`标准时还是有可能会开放使用的。

![](./images/HTTP/14.png)

`OPTIONS`:询问支持的方法

![](./images/HTTP/15.png)

`TRACE`:追踪路径

`TRACE`方法本来就不怎么常用，再加上它容易引发`XST`(Cross-Site Tracing，跨站追踪)攻击，通常就更不会用到了。

`CONNECT`:要求用隧道协议连接代理

`CONNECT`方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行`TCP`通信。主要使用`SSL`(Secure Sockets Layer，安全套接层)和`TLS`(Transport Layer Security，传输层安全)协议把通信内容加密后经网络隧道传输。

![](./images/HTTP/16.png)

### `HTTP/1.0`和`HTTP/1.1`支持的方法

![](./images/HTTP/17.png)

### 建立持久连接节省通信量

`HTTP`协议的初始版本中，每进行一次`HTTP`通信就要断开一次`TCP`连接。

![](./images/HTTP/18.png)

为解决上述`TCP`连接的问题，`HTTP/1.1`和一部分的`HTTP/1.0`想出了持久连接(`HTTP Persistent Connections`，也称为`HTTP keep-alive`或`HTTP connection reuse`)的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持`TCP`连接状态。

![](./images/HTTP/19.png)

持久连接的好处在于减少了`TCP`连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使`HTTP`请求和响应能够更早地结束，这样`Web`页面的显示速度也就相应提高了。

#### 管线化

持久连接使得多数请求以管线化(pipelining)方式发送成为可能。从前发送请求后需等待并收到响应，才能
发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。

![](./images/HTTP/20.png)

### 使用`Cookie`的状态管理

`HTTP`是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。

假设要求登录认证的`Web`页面本身无法进行状态的管理(不记录已登录的状态)，那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。

不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的`CPU`及内存资源的消耗。从另一侧面来说，也正是因为`HTTP`协议本身是非常简单的，所以才会被应用在各种场景里。

保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了`Cookie`技术。`Cookie`技术通过在请
求和响应报文中写入`Cookie`信息来控制客户端的状态。

`Cookie`会根据从服务器端发送的响应报文内的一个叫做`Set-Cookie`的首部字段信息，通知客户端保存`Cookie`。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入`Cookie`值后发送出去。

服务器端发现客户端发送过来的`Cookie`后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

![](./images/HTTP/20.png)

![](./images/HTTP/21.png)

![](./images/HTTP/22.png)