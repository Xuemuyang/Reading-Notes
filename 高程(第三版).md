# Chap1.JavaScript简介

JS诞生-->浏览器表单客户端验证

完整的Javascript实现由以下三个部分组成
> 1. 核心    ECMAScript
> 2. DOM    提供访问和操作网页内容的方法和接口
> 3. BOM    提供与浏览器交互的方法和接口

web浏览器只是ECMAScript的宿主环境之一,Node是服务器端的JavaScript平台

# Chap2.在HTML中使用JavaScript

# Chap3.基本概念

ECMAScript中的一切（变量、函数名和操作符）都区分大小写

标识符即变量、函数、属性的名字，采用驼峰大小写格式

ECMAscript的变量是松散类型的，可以用来保存任何值，未初始化的变量默认值为undefined

可以使用一条语句定义多个变量

```javascript
var message = 'hi',
    found = false,
    age = 29;
```
### 数据类型
> ECMAScript中有5中简单数据类型（也称为基本数据类型）:Undefined、Null、Boolean、Number和String。还有一种复杂数据类型Object,Object本质上是由一组无序名值对（也成键值对或属性值对）组成

#### typeof操作符

typeof操作符可能返回下列字符串
undefined,boolean,string,number,object,function

```javascript
var message = "some string";
alert(typeof message); //"string"
alert(typeof (message)); //"string"
alert(typeof 95); //"number"
```

```javascript
typeof null; // "object"
```
null会被认为是一个空的对象引用

#### Boolean
Boolean类型的字面值true和false是区分大小写的，True和False都不是Boolean值，只是标识符
```javascript
var message = "Hello World!";
var messageAsBoolean = Boolean(message);
```
数据类型 | 转换为true的值 | 转换为false的值
-|-|-
Boolean | true  | false
String | 任何非空字符串  | ""(空字符串)
Number | 任何非零数字值(包括无穷大)  | 0和NaN
Object | 任何对象  | null
Undefined | n/a(not applicate)  | undefined
这些转换规则对理解流程控制语句自动执行相应的Boolean转换非常重要
```javascript
var message = "hehe";
if (message) {
    alert("amazing");
}
```

### Number类型
支持8进制和16进制
```javascript
var octalNum1 = 070; //八进制的56
var octalNum2 = 079; //无效的八进制数---解析为79
var octalNum3 = 08; //无效的八进制数---解析为8（忽略前导的0）
var hexNum1 = 0xA; //十六进制的10
var hexNum2 = 0x1f; //十六进制的31
```
浮点数的运算精度远远不如整数，不要测试浮点数的值

如果某次计算的值超过了JavaScript数值范围的值，那么这个数值将会被自动转换成特殊的Infinity值，如果是负数则会被转换成-Infinity
```javascript
var result = Number.MAX_VALUE + Number.MAX_VALUE;
alert(isFinite(result)); //false
```

#### NaN
NaN(Not a Number)
> 其他编程语言中，任何数值除以非数值都会导致错误，从而停止代码执行。但在ECMAScript中，任何数值除以非数值会返回NaN，因此不会影响其他代码的执行。

NaN有两个特点
1. 任何涉及NaN的操作都会返回NaN
2. NaN与任何值都不相等，包括NaN本身

isNaN()函数判断传入参数是否“不是数值”

利用`NaN`与自身不相等，严格判断`NaN`的方法
```javascript
function myIsNaN(value) { 
  return value !== value; 
} 
```

#### 数值转换
Number(), parseInt(), parseFloat()这个三个函数可以把非数值转换为数值

Number()可以适用于任何数据类型，parseInt()和parseFloat()只适用于字符串

parseInt()指定基数会影响到转换的结果，为避免错误的解析，最好在什么情况下都明确指定基数
```javascript
var num1 = parseInt("10", 2); //2 （按二进制解析）
var num1 = parseInt("10", 8); //8 （按八进制解析）
var num1 = parseInt("10", 10); //10 （按十进制解析）
var num1 = parseInt("10", 16); //16 （按十六进制解析）
```

### String类型
EcmaScript中单引号双引号表示的字符串完全相同

> EcmaScript中的字符串是不可变的，字符串一旦创建，它们的值就不能改变，要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值得字符串填充该变量。

转换为字符串有`toString()`方法

`Number, Boolean, Object , String`都有`toString()`方法，`Null`和`Undefined`没有

调用数值的`toString()`方法时可以传递一个参数:输出数值的基数,默认为10进制

```javascript
var num = 10;
alert(num.toString()); // '10'
alert(num.toString(2)); // '1010'
alert(num.toString(8)); // '12'
alert(num.toString(10)); // '10'
alert(num.toString(16)); // 'a'
```

`String()`函数适用于`null`和`undefined`,返回`'null'`和`'undefined'`，如果值有`toString()`方法，则调用`toString()`方法

### Object类型
Object的每个实例都具有下列属性和方法
1. `constructor`:保存着用于创建当前对象的函数，如果是`var o = new Object();`，那么构造函数`constructor`就是`Object()`。
2. `hasOwnProperty(propertyName)`:用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中`propertyName`必须以字符串的形式指定。
3. `isPrototypeOf(object)`:用于检查传入的对象是否是当前对象的原型。
4. `propertyIsEnumerable(propertyName)`:用于检查给定的属性是否能够使用for-in语句来枚举，同样传入的`propertyName`必须以字符串的形式指定。
5. `toLocaleString()`:返回对象的字符串表示，该字符串与执行环境的地区对应。
6. `toString()`:返回对象的字符串表示。
7. `valueOf()`:返回对象的字符串、数值或布尔值表示。

### 操作符
> EcmaScript操作符的与众不同之处出在于，它们能够适用于很多值，应用于对象时，相应的操作符通常会调用对象的valueOf()和toString()方法，以便取得可以操作的值。
#### ++ --操作符
执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的
```javascript
var age = 29;
var anotherAge = --age +2;

alert(age); // 输出28
alert(anotherAge); //输出30
```
后置递增递减则是在语句被求值以后执行
```javascript
var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2; // 等于22
var num4 = num1 + num2; // 等于21
```

#### 一元加和减操作符
> 对非数值应用一元加号操作符时，该操作会像Number()转型函数一样对这个值执行转换。`++`,`--`，操作也是如此
```javascript
var s1 = '01';
var a = '01';
var s2 = '1.1';
var s3 = 'z';
var b = false;
var f = 1.1;
var o = {
    valueOf: function () {
        return -1;
    }
};

s1 = +s1; // 值变成数值1
a++; // 值变成2
s2 = +s2; // 值变成数值1.1
s3 = +s3; // 值变成NaN
b = +b; // 值变成数值0
f = +f; // 值未变，仍然是1.1
o = +o; // 值变成数值-1
```

#### 位操作符
> 位操作符用在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。
1. 按位非（NOT）`~`
2. 按位与 (AND) `&`
3. 按位或 (OR) `|`
4. 按位异或 (XOR) `^` 两个数值对应位上只有一个1时才返回1
5. 左移 `<<` 左移不会影响符号位
6. 有符号的右移 `>>`
7. 无符号右移 `>>>`

#### 逻辑非
> `!`可以应用与ECMAScript中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。

`!!`同时使用两个逻辑非操作符，实际上会模拟Boolean()转型函数的行为。
```javascript
alert(!!'blue'); //true
alert(!!0); //false
alert(!!NaN); //false
alert(!!''); //false
alert(!!12345); //true
```

#### 逻辑与`&&`逻辑或`||`
牢记是短路操作符！！！，如果第一个操作数的求值结果能够决定结果就不会对第二个操作数求值。

逻辑与或可以应用于任何类型的操作数，不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与或操作不一定返回布尔值。

```javascript
alert(0||1);//1
alert('a'||1);//'a'
alert(''||0);//0
```

1、只要`||`前面为false,不管`||`后面是true还是false，都返回`||`后面的值。
2、只要`||`前面为true,不管`||`后面是true还是false，都返回`||`前面的值。

```javascript
alert(''&&1);//''
alert('a'&&1);//1
alert(0&&''); //0
```

1、只要`&&`前面是false，无论`&&`后面是true还是false，结果都将返`&&`前面的值;
2、只要`&&`前面是true，无论`&&`后面是true还是false，结果都将返`&&`后面的值;

**简单应用**

假设需求：
+ 成长速度为5显示1个箭头；
+ 成长速度为10显示2个箭头；
+ 成长速度为12显示3个箭头；
+ 成长速度为15显示4个箭头；
+ 其他都显示都显示0个箭头。

`if-else`
```javascript
var add_level = 0; 
if(add_step == 5){ 
    add_level = 1; 
} else if(add_step == 10){ 
    add_level = 2; 
} else if(add_step == 12){ 
    add_level = 3; 
} else if(add_step == 15){ 
    add_level = 4; 
} else { 
    add_level = 0; 
}
```

`switch-case`
```javascript
var add_level = 0; 
switch(add_step){
    case 5 : add_level = 1; 
    break; 
    case 10 : add_level = 2; 
    break; 
    case 12 : add_level = 3; 
    break; 
    case 15 : add_level = 4; 
    break; 
    default : add_level = 0; 
    break;
}
```

```javascript
var add_level = (add_step==5 && 1) || (add_step==10 && 2) || (add_step==12 && 3) || (add_step==15 && 4) || 0;
```

```javascript
var add_level={'5':1,'10':2,'12':3,'15':4}[add_step] || 0;
```

高级需求：
+ 成长速度为>12显示4个箭头；
+ 成长速度为>10显示3个箭头；
+ 成长速度为>5显示2个箭头；
+ 成长速度为>0显示1个箭头；
+ 成长速度为<=0显示0个箭头。

```javascript
var add_level = (add_step>12 && 4) || (add_step>10 && 3) || (add_step>5 && 2) || (add_step>0 && 1) || 0;
```

#### 加性操作符
+ 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
+ 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来
+ 如果有一个操作数是对象、数值或布尔值，调用它们的toString()方法取得相应的字符串值。
```javascript
var num1 = 5;
var num2 = 10;
var message = 'The  sum of 5 and 10 is ' + num1 + num2;
alert(message); // "The sum of 5 and 10 is 510"
```

#### 减法
+ 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN;
+ 如果有一个操作数是对象，调用对象的valueOf()方法取得表示该对象的数值。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。
```javascript
var result1 = 5 - true; // 4
var result2 = NaN - 1; // NaN
var result3 = 5 - 3; // 2
var result4 = 5 - ''; // 5
var result 5 = 5 - '2'; // 3 
var result 6 = 5 - null; // 5
```
#### 关系操作符
#### ``` > < <= >=```操作符
如果两个操作数都是字符串，则比较两个字符串对应的字符编码值
#### 相等操作符
> ECMAScript提供了两组操作符：相等和不相等---先转换再比较，全等和不全等---仅比较而不转换。

##### `==`与`!=`
+ 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较;
+ null和undefined是相等的;
+ 如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象则相等操作符返回true；否则，返回false;
+ NaN与任何值都不相等，包括NaN。

##### `===`
全等要求数据类型也相等

#### 条件操作符（三元运算符）
`var max = (num1 > num2) ? num1 : num2;`


**总结：比较规则有很多，关键是操作符期望是什么操作数，往期望操作符的类型去转换，比如期望得到数值，object就先调用`valueOf()`方法，期望得到字符串，object就先调用`toString()`方法**

### 语句
#### `if`语句
ECMAScript会自动调用`Boolean()`转换函数将这个表达式的结果转换为一个布尔值。
#### `for-in`语句
```javascript
for (var propName in window) {
    document.write(propName);
}
```
> ECMAScript对象的属性没有顺序，因此通过`for-in`循环输出的属性名的顺序是不可预测的。

#### `label`语句与`break`,`continue`
`label`语句在代码中添加标签，可以在将来由break或continue语句引用。
```javascript
var num = 0;

outermost:
for (var i = 0; i < 10; i++) {
    for (var j = 0; j < 10; j++) {
        if (i == 5 && j == 5) {
            break outermost;
        }
        num++;
    }
}

alert(num); //55
```

#### `switch`语句
```javascript
switch (i) {
    case 25:
        alert('25');
        break;
    case 35:
        alert('35');
        break;
    case 45:
        alert('45');
        break;
    default:
        alert('Other');
}
```
可以在switch语句中使用任何数据类型
```javascript
switch ('hello world') {
    case 'hello ' + 'world':
        alert('Greeting was found.');
    default:
        alert('Unexpected message was found');
}
```

### 函数
> 函数会在执行完return语句之后停止并立即退出。因此，return之后的任何代码永远不会执行。

ECMAScript中的参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。`arguments`类数组，可以通过索引访问传入参数的值

> `arguments`的值永远与对应命名参数的值保持同步

```javascript
function doAdd (uum1, num2) {
    arguments[1] = 10;
    alert(arguments[0] + num2);
}
```
每次执行`doAdd`都会重写第二个参数，将第二个参数的值修改为10.因为`arguments`对象中的值会自动反映到对应的命名参数，所以修改`arguments[1]`，也就修改了`num2`,结果它们的值都会变成10。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但是它们的值会同步。另外还要记住，如果只传入了一个参数，那么`arguments[1]`设置的值不会反映到命名参数中。这是因为`arguments`对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。没有被传递值的命名参数为undefined。

> ECMAScript不能实现传统意义上的重载。

## chap4.变量、作用域和内存问题
### 基本类型和引用类型的值
`Undefined`,`Null`,`Boolean`, `Number`,`String`五种基本类型的数据按值访问，基本类型值在内存中占据固定大小的空间，保存在栈内存中。`Object`引用类型按引用访问，引用类型的值是对象，保存在堆内存中。

```javascript
var num1 = 5;
var num2 = num1;
```
num1与num2中的值是完全独立的，复制完成之后这两个变量可以参与任何操作而不会相互影响。

当从一个变量向另一个变量复制引用类型的值时，这个值实际上是指针，这个指针指向堆内存中的一个对象，复制完成之后，两个变量实际上将引用同一个对象。

#### 传递参数
> ECMAScript中所有函数的参数都是按值传递的。

基本类型值的传递如同基本类型变量的复制一样。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

```javascript
function setName(obj) {
    obj.name = 'Nicholas';
    obj = new Object();
    obj.name = 'Greg';
}

var person = new Object();
setName(person);
alert(person.name); //'Nicholas'
```
引用类型参数传递也是按值传递，传入地址，person与obj共同管理一个对象，接着给这个对象name属性赋值，后来的操作是让obj去管理另一个对象，即改变obj的引用，person的引用不会改变。实际上obj引用的是一个局部对象，这个局部对象在函数执行完毕之后立即被销毁。

### 执行环境及作用域
> 执行环境（execution context）定义了变量或函数有权访问的其他数据。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。

全局执行环境是最外围的一个执行环境。根据ECMAScript实现的宿主环境不同，表示执行环境的东西也不同。Web浏览器中，全局执行环境被认为是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境知道应用程序退出---例如关闭浏览器或网页时才会被销毁）。

每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着。

当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始只包含一个变量，即`arguments`对象（这个对象在全局环境中是不存在的）。

内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。

+ 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
+ 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链。

#### 延长作用域链
`try-catch`语句的`catch`块

#### 没有块级作用域
```javascript
if (true) {
    var color = 'blue';
}

alert(color); //"blue"
```
在C、C++、Java中，color会在`if`语句执行完毕后被销毁，在JavaScript中，`if`语句中的变量声明会将变量添加到当前的执行环境（这里是全局环境）中。使用for语句时由其牢记这一差异，例如：
```javascript
for (var i = 0; i < 10; i++) {
    doSomething(i);
}

alert(i); //10
```
> 使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；如果初始化变量时没有使用var声明，该变量会被添加到全局环境。

如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。
```javascript
var color = 'blue';

function getColor () {
    var color = 'red';
    return color;
}

alert(getColor()); //"red"
```

## chap5.引用类型
> 引用类型的值（对象）是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。

### Object类型
创建Object实例的方式有两种
1. 使用`new`操作符后跟Object构造函数
```javascript
var person = new Object();
person.name = 'Nicholas';
person.age = 29;
```
2. 使用对象字面量表示法
```javascript
var person = {
    name : 'Nicholas',
    age : 29
};
```
> 在这个例子中，左边的花括号（{）表示对象字面量的开始，因为它出现在了表达式上下文(expression context)中。ECMAScript中的表达式上下文指的是该上下文期待的一个值（表达式）。赋值操作符表示后面是一个值，所以左花括号在这里表示一个表达式的开始。同样的花括号，如果出现在一个语句上下文（statement context）中，例如跟在if语句条件的后面，则表示一个语句块的开始。

理解一个操作符期望得到什么对于理解JS非常重要！

JavaScript中也可以使用方括号表示法来访问对象属性

使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中。
```javascript
alert(person['name']); //"Nicholas"
```
方括号语法的主要优点是可以通过变量来访问属性。
```javascript
var propertyName = 'name';
alert(person[pripertyName]); //"Nicholas"
```
如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号语法。
```javascript
person['first name'] = 'Nicholas';
```
除非必须使用变量来访问属性，否则使用点表示法！

### Array类型
ECMAScript数组与其他语言中的数组都是数据的有序列表，与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据，另外数组的大小可以动态调整，即可以随着数据的添加自动增长以容纳新数据。

创建数组的基本方式有两种
1. Array构造函数
```javascript
var colors = new Array();
```
如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量
```javascript
var colors = new Array(20);
```
也可以向Array构造函数传递数组中应该包含的项
```javascript
var colors = new Array('red', 'blue', 'green');
```
给构造函数传递一个值也可以创建数组
```javascript
var colors = new Array(3); // 创建一个包含3项的数组
var names = new Array('greg'); // 创建一个包含1项，即字符串"greg"的数组
```
在使用构造函数的时候也可以省略new操作符，结果相同。

2. 字面量表示法
```javascript
var colors = ['red', 'green', 'blue'];
```

##### length属性
> 数组的length属性很有特点---它不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。
```javascript
var num = [1, 2, 3];
num.length = 2;
alert(num[2]); //undefined
```
这个例子中移除了数组位置为2的那一项，如果将`length`属性设置为大于数组项数的值，则新增的每一项都会去的`undefined`值
```javascript
var num = [1, 2, 3];
num.length = 4;
alert(num[3]); //undefined
```

利用`length`属性可以方便地在数组末尾添加新项
```javascript
var num = [1, 2, 3];
num[num.length] = 4;
```
> 数组最多可以包含4294967295个项，如果添加的项数超过这个上限，就会发生异常。

#### Array的API
##### 检测数组
`Array.isArray(value)` 确定某个值是否是数组

##### 转换方法
> 所有对象都具有`toLocaleString()`、`toString()`、`valueOf()`方法。调用数组的`toString()`方法会返回由数组中的每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用`valueOf()`返回的还是数组。实际上，为了创建这个字符串会调用数组每一项的`toString()`方法。
```javascript
var colors = ['red', 'green', 'blue'];
alert(colors.toString()); //red,green,blue
alert(colors.valueOf()); //red,green,blue
alert(colors); //red,green,blue
```
在这里，我们首先显示地调用了`toString()`方法，以便返回数组的字符串表示，每个值的字符串表示拼接成了一个字符串，中间以逗号分隔。接着调用`valueOf()`方法，而最后一行代码直接将数组传递给了`alert()`。由于`alert()`要求接受字符串参数，所以它会在后台调用`toString()`方法，由此会得到与直接调用`toString()`方法相同的结果。

`toLocaleString()`方法不同的是调用的是每一项的`toLocaleString()`方法。

`join()`方法将数组中的项通过不同的分隔符来构建字符串
```javascript
var colors = ['red', 'green', 'blue'];
alert(colors.join(',')); //red,green,blue
alert((colors.join('||'); //red||green||blue
```
```javascript
function repeatString(str,n) {
    return new Array(n+1).join(str);
}
repeatString('a',3);//"aaa"
repearString('Hi',5);//"HiHiHiHiHi"
```

##### 栈方法
栈(stack)是一种LIFO(Last-In-First-Out，后进先出)的数据结构，类比于堆叠起来的盘子。栈中的插入push(推入)和移除pop(弹出)，只发生在栈的顶部。

`push()`方法接受任意数量的参数，将它们逐个添加到数组末尾，返回修改后数组的长度

`pop()`方法从数组末尾移除最后一项，减少数组的`length`值，然后返回移除的项

##### 队列方法
队列(queue)数据结构的访问规则是FIFO(First-In-First-Out，先进先出)。

`shift()`移除数组中的第一个项并返回该项，同时数组长度减1。结合使用`shift()`和`push()`方法，可以像用队列一样使用数组。

`unshift()`在数组前端添加任意个项并返回新数组的长度，使用`unshift()`和`pop()`方法可以从相反的方向来模拟队列。

##### 重排序方法
`reverse()`方法，反转数组项的顺序,返回值是经过排序后的数组，会改变原数组

`sort()`方法会调用每个数组项的`toString()`转型方法，然后比较得到的字符串，按ASCII进行比较。
```javascript
var values = [0, 1, 5, 10, 15];
values.sort();
alert(values); //0,1,10,15,5
```
`sort()`方法可以接收一个比较函数作为参数，比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。

```javascript
function compare (val1, val2) {
    return val1 - val2;
}

var values = [0, 5, 1, 10, 15];
values.sort(compare);
alert(values); //0,1,5,10,15
```
`sort()`方法的原理是冒泡算法

##### 操作方法
`concat()` 方法用于连接两个或多个数组。
该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。在没有给`concat()`方法传递参数的情况下，它只是赋值当前数组并返回副本。如果传递给`concat()`的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。

```javascript
var colors = ['red', 'green', 'blue'];
var colors = colors.concat('yellow', ['black', 'brown']);

alert(colors); //red,green,blue
alert(colors); //red,green,blue,yellow,black,brown
```
`slice()`方法基于当前数组切出一个新数组，不会影响原来的数组
```javascript
var colors = ['red', 'green', 'blue', 'yellow', 'purple'];
var colors2 = colors.slice(1);
var colors3 = colors.slice(1,4);

alert(colors2); //green,blue,yellow,purple
alert(colors3); //green,blue,yellow
```
> 如果`slice()`方法的参数有负数，则用数组长度加上该数来确定相应的位置。

`splice()`方法向数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组。

`splice(val1, val2, val3)`
+ `val1`是索引，从什么位置开始操作
+ `val2`是项数，删除几项
+ `val3`是插入的项，可以插入任意数量
```javascript
var colors = ['red', 'green', 'blue'];
var removed = colors.splice(0,1);
alert(colors); //green,blue
alert(removed); //red，返回的数组中只包含一项

removed = colors.splice(1, 0, 'yellow', 'orange');
alert(colors); //green,yellow,orange,blue
alert(removed); //返回的是一个空数组

removed = colors.splice(1, 1, 'red', 'purple');
alert(colors); //green,red,purple,orange,blue
alert(removed); //yellow，返回的数组中只包含一项
```
##### 位置方法
`indexOf()`和`lastIndexOf()`。这两个方法都接受两个参数：要查找的项和（可选）表示查找起点位置的索引。其中`indexOf()`方法从数组的开头（位置0）开始向后查找，`lastIndexOf()`方法则从数组的末尾开始向前查找。两个方法都返回要查找项在数组中的位置，没找到的情况下返回-1。
```javascript
var numbers = [1,2,3,4,5,4,3,2,1];

alert(numbers.indexOf(4)); //3
alert(numbers.lastIndexOf(4)); //5

alert(numbers.indexOf(4,4)); //5
alert(numbers.lastIndexOf(4,4)); //3
```
##### 迭代方法
ECMAScript5为数组定义了5个迭代方法。每个方法都接受两个参数：要在每一项上运行的函数和（可选）运行该函数的作用域对象---影响this的值。传入这些方法的函数会接受三个参数：数组项的值、该项数组中的位置和数组对象本身。
+ `every()`:对数组中的每一项运行给定函数，如果该函数对每一项都返回`true`,则返回`true`。
+ `some()`:对数组中的每一项运行给定函数，如果该函数任意一项返回`true`,则返回`true`。
+ `filter()`:对数组中的每一项运行给定函数，返回该函数会返回`true`的项组成的数组。
+ `map()`:对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
+ `forEach()`:对数组中的每一项运行给定函数，这个方法没有返回值。
```javascript
var numbers = [1,2,3,4,5,4,3,2,1];

var everyResult = numbers.every(function (item, index, array) {
    return (item > 2);
});

alert(everyResult); //false

var someResult = numbers.some(function (item, index, array) {
    return (item > 2);
});

alert(someResult); //true
```
```javascript
var numbers = [1,2,3,4,5,4,3,2,1];

var filterResult = numbers.filter(function (item, index, array) {
    return (item > 2);
});

alert(filterResult); //[3,4,5,4,3]
```
```javascript
var numbers = [1,2,3,4,5,4,3,2,1];

var mapResult = numbers.map(function (item, index, array) {
    return item * 2;
});

alert(mapResult); //[2,3,4,6,8,10,8,6,4,2]
```
```javascript
var numbers = [1,2,3,4,5,4,3,2,1];

numbers.forEach(function (item, index, array) {
    numbers[index] += index;
});

alert(numbers); //[1,3,5,7,9,9,9,9,9]
```
##### 归并方法
ECMAScript5新增了两个归并数组的方法：`reduce()`和`reduceRight()`。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。`reduce()`方法从数组的第一项开始，逐个遍历到最后。`reduceRight()`从数组的最后一项开始，向前遍历到第一项。

这两个方法都接收两个参数：一个在每一项上调用的函数和（可选）作为归并基础的初始值。传给这两个方法的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。如果传入归并初始值，则从第一项开始迭代。否则第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。
```javascript
var total = [0, 1, 2, 3].reduce(function(sum, value) {
  return sum + value;
}, 0);
// total is 6

var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) {
  return a.concat(b);
}, []);
// flattened is [0, 1, 2, 3, 4, 5]

var values = [1, 2, 3, 4, 5].reduce(function(prev, cur, index, array) {
    return prev + cur;
};
alert(values); //15

var values = [1, 2, 3, 4, 5];
var sum = values.reduceRight(function(prev, cur, index, array) {
    return prev + cur;
}, 10);
alert(sum); //25
```

### RegExp类型
##### RegExp基础
.|任意字符（除换行符以外：\n,\r,\u2028 or \u2029）|/.../.test('1a@')';
---|---|---
\d |数字0-9|/\d\d\d/.test('123');
\D |非\d，即不是数字0-9的字符|/\D\D\D/.test('ab!');
\w |数字0-9，或字母a-z及A-Z（大小写），或下划线）|/\w\w\w\w/.test('aB9_');
\W |非\w|/\W\W\W/.test('@!#');
\s |空格符、TAB、换页符、换行符|/\sabc/.test(' abc');
\s |非\s|
\t\r\n\v\f|tab 回车 换行 垂直制表符 换页符

##### 范围符号
[abcd]表示这个字符只能是abcd中的一个
[...]|字符范围|[a-z] [0-9] [A-Z0-9a-z_]
---|---|---
[^...]|字符范围以外|[^a-z] [^abc]
^|行首|^Hi
$|行尾|test$
\b|零宽单词边界|\bno
\B|非\b|

##### 分组
\n可能分了好几组，n代表分组的序号
(x)|分组，并记录匹配到的字符串|/(abc)/
---|---|---
\n|表示使用分组符(x)匹配到的字符串|/(abc)\1/.test('abcabc');
(?:x)|仅分组|(?:abc)(def)\1/.test('abcdefdef');

##### 重复
x* x+|重复次数>=0 重复次数>0 贪婪算法|正则表达式：abc*将匹配ab、abc/abccccc 正则表达式：abc+将匹配abc、abcccc、却不匹配ab
---|---|---
x*? x+?|同x*,x+,非贪婪算法|正则表达式：abc*?在字符串abcccccc中将匹配ab，abc+？则匹配abc。
x?|出现0或1次|
x\|y|x或者y|x\|y匹配x，也匹配y 再比如：ab\|cd\|ef匹配ab或cd或ef
x{n}x{n,}x{n,m}|重复n次，重复>=n次，重复次数满足n<=x<=m|x{5}匹配xxxxx，不匹配xxo，x{1，3}匹配x，xx，xxx

ECMAScript通过RegExp类型来支持正则表达式。

`var expression = / pattern / flags ;`

pattern（模式）部分是正则表达式，每个正则表达式都可带有一或多个flags

+ **g**：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
+ **i**：表示不区分大小写（case-insensitive）模式；
+ **m**：表示多行（multiple）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

模式中使用的所有元字符必须转义。正则表达式中的元字符包括：

`( [ { \ ^ $ | ) ? * + . ] }`

还可以通过`RegExp`构造函数创建正则表达式
```
/*
* 匹配第一个'bat'或'cat'，不区分大小写
*/
var pattern1 = \[bc]at\i;

/*
* 与pattern1相同，只不过是使用构造函数创建的
*/
var pattern2 = new RegExp('[bc]at', 'i')
```
由于`RegExp`构造函数的模式参数是字符串，某些情况需要双重转义
字面量模式|等价的字符串
---|---
/\\[bc\\]at/|'\\\\[bc\\\\]at'
/\\.at/|'\\\\.at'
/name\\/age/|'name\\\\/age'

##### RegExp实例属性
+ `global` ：布尔值，是否设置g标志
+ `ignoreCase`：布尔值，是否设置i标志
+ `lastIndex`：整数，表示开始搜索下一个匹配项的字符位置，从0算起。
+ `multiline`：布尔值，是否设置m标志
+ `source`：正则表达式的字符串表示，按照字面量形式返回。

```javascript
var pattern1 = /\[bc\]at/i;

alert(pattern1.global); //false
alert(pattern1.ignoreCase); //true
alert(pattern1.multiline); //false
alert(pattern1.lastIndex); //0
alert(pattern1.source); //"\[bc\]at"
```
##### RegExp实例方法
+ `compile()`：编译正则表达式。
+ `exec()`：检索字符串中指定的值。返回找到的值，并确定其位置。
+ `test()`：检索字符串中指定的值。返回`true`或 `false`。

`exec()`专为捕获组设计，返回包含第一个匹配项信息的数组，数组包含两个额外的属性`index`和`input`,`index`是匹配项在字符串中的位置，`input`表示应用正则表达式的字符串。
```javascript
var text = 'mom and dad and baby';
var pattern = /mom( and dad( and baby)?)?/gi;

var matches = pattern.exec(text);
alert(matches.index); //0
alert(matches.input); //"mom and dad and baby"
alert(matches[0]); //"mom and dad and baby"
alert(matches[1]); //"and dad and baby"
alert(matches[2]); //" and baby"
```
即使使用g标签，每次只返回一个匹配项，不设置g标签的情况下，同一个字符串上多次调用`exec()`将始终返回第一个匹配项的信息，每次调用都会在字符串中继续查找新匹配项。
```javascript
var text = 'cat, bat, sat, fat';
var pattern1 = /.at/;

var matches = pattern1.exec(text);
alert(matches.index); //0
alert(matches[0]); //cat
alert(pattern1.lastIndex); //0

matches = pattern1.exec(text);
alert(matches.index); //0
alert(matches[0]); //cat
alert(pattern1.lastIndex); //0

var pattern2 = /.at/g;

var matches = pattern2.exec(text);
alert(matches.index); //0
alert(matches[0]); //cat
alert(pattern1.lastIndex); //3

matches = pattern2.exec(text);
alert(matches.index); //5
alert(matches[0]); //bat
alert(pattern1.lastIndex); //8
```
`test()`方法接受一个字符串参数。在模式与该参数匹配的情况下返回true，否则，返回false。
```javascript
var text = '000-00-0000';
var pattern = /\d{3}-\d{2}-\d{4}/;

if (pattern.test(text)) {
    alert('The pattern was matched.');
}
```
`RegExp`实例继承的`toLocaleString()`和`toString()`方法都会返回正则表达式的字面量。

### Function类型
函数实际上是对象，每个函数都是Function类型的实例，函数名实际上是一个指向函数对象的指针。


函数名是指向函数的指针，函数名与包含对象指针的其他变量没有什么不同。一个函数可能有多个名字。使用不带括号的函数名是访问函数指针而非调用函数。
```javascript
function sum(num1, num2) {
    return num1 + num2;
}
alert(sum(10,10)); //20

var anotherSum = sum;
alert(another(10,10)); //20

sum = null;
alert(anotherSum(10,10)); //20
```

##### 没有重载
将函数名想象为指针，理解ECMAScript中没有函数重载的概念。
```javascript
var addSomeNumber = function(num) {
    return num + 100;
};

addSomeNumber = function(num) {
    return num + 200;
};

var result = addSomeNumber(100); //300
```
##### 函数声明与函数表达式
函数声明提升（function declaration hoisting）
```javascript
alert(sum(10,10));
function sum(num1, num2) {
    return num1 + num2;
}
```
改为函数表达式则会产生错误
```javascript
alert(sum(10,10));
var sum = function(num1, num2) {
    return num1 + num2;
}
```
##### 作为值的函数
实例：对数组中的对象排序
```javascript
function createComparisonFunction(propertyName) {
    return function(object1, object2) {
        var value1 = object1[propertyName];
        var value2 = object2[propertyName];
        
        if (value1 < value2) {
           return -1; 
        } else if (value1 > value2) {
            return 1;
        } else {
            return 0;
        }
    };
}
```
```javascript
var data = [{name: 'xmy', age: 22}, {name: 'yl', age: 21}];

data.sort(createComparisonFunction('name'));
alert(data[0].name); //xmy

data.sort(createComparisonFunction('age'));
alert(data[0].name); //yl
```

##### 函数内部属性
`arguments.callee`是一个指向正在执行的函数的指针。
```javascript
function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}
```
`this`是函数内部的对象，`this`引用的是函数执行的环境对象。

`caller`函数对象的属性。调用当前函数的函数的引用。如果在全局作用域中调用当前函数，它的值为null。

##### 函数属性和方法
每个函数都包含两个属性：`length`和`prototype`。其中`length`属性表示函数期望接受的命名参数的个数。
```javascript
function sayName(name) {
    alert(name);
}

function sum(sum1, sum2) {
    return num1 + num2;
}

function sayHi() {
    alert('hi');
}

alert(sayName.length); //1
alert(sum.length); //2
alert(sayHi.length); //0
```

`apply()`和`call()`这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内`this`对象的值。这两个方法的区别在于接收参数的方式不同，`apply()`第二个参数可以使`Array`的实例也可以是`arguments`对象，`call()`的参数必须逐个列举出来。
```javascript
function sum(num1, num2) {
    return num1 + num2;
}

function callSum1(num1, num2) {
    return sum.apply(this, [num1, num2]); //传入数组
}

alert(callSum1(10,10)); //20
```

```javascript
function sum(num1, num2) {
    return num1 + num2;
}

function callSum1(num1, num2) {
    return sum.call(this, num1, num2);
}

alert(callSum1(10,10)); //20
```
`apply()`和`call()`的真正用武之地在于能够扩充函数的作用域。
```javascript
window.color = 'red';
var o = { color: 'blue'};

function sayColor() {
    alert(this.color);
}

sayColor(); //red

sayColor.call(this); //red
sayColor.call(window); //red
sayColor.call(o); //blue
```
```javascript
function cat() {};
cat.prototype = {    
    food:"fish",
    say: function() {
        alert("I love "+ this.food);
    }
}
var blackCat = new cat;
blackCat.say();
```
但是如果我们有一个对象`whiteDog = {food:"bone"}`,我们不想对它重新定义`say`方法，那么我们可以通过`call`或`apply`用`blackCat`的`say`方法：`blackCat.say.call(whiteDog)`;所以，可以看出`call`和`apply`是为了动态改变`this`而出现的，当一个`object`没有某个方法，但是其他的有，我们可以借助`call`或`apply`用其它对象的方法来操作。

`bind()`方法会创建一个函数的实例，其`this`值会被绑定到传给`bind()`函数的值
```javascript
window.color = 'red';
var o = { color: 'blue'};

function sayColor() {
    alert(this.color);
}
var objectSayColor = sayColor.bind(o);
objectSayColor(); //blue
```

### 基本包装类型
为了便于操作基本类型值，ECMAScript提供了3个特殊的引用类型：Boolean、Number和String，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而 可以调用一些方法来操作这些数据。

引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。
```javascript
var s1 = 'some text';
s1.color = 'red';
alert(s1.color); //undefined
```

对基本包装类型的实例调用`typeof`会返回`"object"`
#### Boolean类型
`Boolean`类型的实例重写了`valueOf()`，返回基本类型值`true`或`false`；重写了`toString()`方法，返回字符串`"true"`和`"false"`。
```javascript
var falseObject = new Boolean(false);
var result = falseObject && true;
alert(result); //true
```
布尔表达式中所有的对象都会被转换为`true`
#### Number类型
与`Boolean`类型一样，`Number`类型也重写了`valueOf()`，`toLocaleString()`，`toString()`方法。重写后的`valueOf()`方法返回对象的基本类型的数值，另外两个方法则返回字符串形式的数值。
```javascript
var num = 10;
alert(num.toString()); // '10'
alert(num.toString(2)); // '1010'
alert(num.toString(8)); // '12'
alert(num.toString(10)); // '10'
alert(num.toString(16)); // 'a'
```
`toFixed()`方法会按照指定的小数位返回数值的字符串表示，能够自动舍入的特性，使得`toFixed()`方法很适合处理货币，传入一个参数为小数位数。
```javascript
var num = 10;
alert(num.toFixed(2)); //"10.00"

var num = 10.005;
alert(num.toFixed(2)); //"10.01"
```
`toExponential()`该方法返回以指数表示法（也称e表示法），传入参数为小数位数。
```javascript
var num = 10;
alert(num.toExponential(1)); //"1.0e+1"
```
如果想得到表示某个数值的最合适的格式，使用`toPrecision()`，参数为数字的位数。
```javascript
var num = 99;
alert(num.toPreicision(1)); //"1e+2"
alert(num.toPreicision(2)); //"99"
alert(num.toPreicision(3)); //"99.0"
```
不建议显式实例化`Number`类型，使用`typeof`和`instanceof`操作符测试基本类型数值与引用类型数值时，得到的结果完全不同。
```javascript
var numberObject = new Number(10);
var numberValue = 10;
alert(typeof numberObject); //"object"
alert(typeof numberValue); //"number"
alert(numberObject instanceof Number); //true
alert(numberValue instanceof Number); //false
```
#### String类型

`String`类型的每个实例都有一个`length`属性
```javascript
var stringValue = 'hello world';
alert(stringValue.length); //"11"
```
##### 字符方法

```javascript
var stringValue = 'hello world';
alert(stringValue.charAt(1)); //"e"
```
```javascript
var stringValue = 'hello world';
alert(stringValue.charCodeAt(1)); //"101"
```
`String`构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一个或字符编码，然后将它们转换为一个字符串。

```javascript
alert(String.fromCharCode(104, 101, 108, 108, 111)); //"hello"
```

##### 字符串操作方法
`concat()`用于将一个或多个字符串拼接起来，返回拼接得到的新字符串。

```javascript
var stringValue = 'hello';
var result = stringValue.concat('world', '!');

alert(result); //"hello world!"
alrt(stringValue); //"hello"
```

实践中使用更多的还是加号操作符(+)。

ECMAScript提供了三个基于子字符串创建的新字符串的方法：`slice()`，`substr()`,`substring()`。
```javascript
var stringValue = 'hello world';

alert(stringValue.slice(3)); //"lo world"
alert(stringValue.substring(3)); //"lo world"
alert(stringValue.substr(3)); //"lo world"

alert(stringValue.slice(3, 7)); //"lo w"
alert(stringValue.substring(3, 7)); //"lo w"
alert(stringValue.substr(3, 7)); //"lo worl"
```
`slice()`，`substring()`第二个参数是切到第几位，`substr()`是切几位。
```javascript
var stringValue = 'hello world';

alert(stringValue.slice(-3)); //"rld"
alert(stringValue.substring(-3)); //"hello world"
alert(stringValue.substr(-3)); //"rld"

alert(stringValue.slice(3, -4)); //"lo w"
alert(stringValue.substring(3, -4)); //"hel"
alert(stringValue.substr(3, -4)); //""
```
+ `slice()`会将传入的负值与字符串长度相加
+ `substring()`会把所有的负数都转换为0，本例中`substring(3, 0)`由于这个方法会将较小的数作为开始位置，相当于`substring(0, 3)`
+ `substr()`将负的第一个参数加上字符串的长度，第二个参数转换为0

##### 字符串位置方法

与数组方法类似
```javascript
var stringValue = 'hello world';
alert(stringValue.indexOf('o')); //4
alert(stringValue.lastIndexOf('o')); //7

alert(stringValue.indexOf('o', 6)); //7
alert(stringValue.lastIndexOf('o', 6)); //4
```
两个方法都可以接收第二个参数，表示从字符串的哪个位置开始搜索，`indexOf()`会从该参数指定的位置向后搜索，`lastIndexOf()`会从该参数指定的位置向前搜索。

循环调用`indexOf()`或`lastIndexOf()`来找到所有匹配的子字符串。

```javascript
var stringValue = 'Lorem ipsum dolor sit amet,, consectetur adipisicing elit';
var positions = [];
var pos = stringValue.indexOf('e');

while (pos > -1) {
    positions.push(pos);
    pos = stringValue.indexOf('e', pos + 1);
}

alert(position); //"3,24,32,35,52"
```

##### `trim()`方法
`trim()`方法会创建一个字符串的副本，删除前置以及后缀的所有空格，然后返回结果。
```javascript
var stringValue = "   hello world   ";
var trimmedStringValue = stringValue.trim();
alert(stringValue); //"   hello world   "
alert(trimmedStringValue); //"hello world"
```

##### 字符串大小写转换方法
`toUpperCase()`，`toLowerCase()`,借鉴自java.lang.String中的同名方法。
`toLocaleUpperCase()`，`toLocaleLowerCase()`方法则是针对特定地区的实现。

##### 字符串的模式匹配方法
`match()`方法本质上与调用RegExp的`exec()`方法相同，`match()`只接受一个参数，正则表达式，或者RegExp对象。

```javascript
var text = 'cat, bat, sat, fat';
var pattern = /.at/;

//与pattern.exec(text)相同
var matches = text.match(pattern);
alert(matches.index); //0
alert(matches[0]); //"cat"
alert(pattern.lastIndex); //0
```
如果进行全局匹配，则一次匹配到所有项
```javascript
var text = 'cat, bat, sat, fat';
var pattern = /.at/g;

var matches = text.match(pattern);
alert(matches); //cat,bat,sat,fat
```

`search()`方法返回字符串中第一个匹配项的索引，如果没有找到匹配项，则返回-1、
```javascript
var text = 'cat, bat, sat, fat';
var pos = text.search(/at/);
alert(pos); //1
```

`replace()`方法
如果第一个参数是字符串，只会替换第一个子字符串。想要替换所有子字符串，唯一的办法是提供正则表达式，且指定全局（g）标志。
```javascript
var text = 'cat, bat, sat, fat';
var result = text.replace('at', 'ond');
alert(result); //"cond, bat, sat, fat"

result = text.replace(/at/g, 'ond');
alert(result); //"cond, bond, sond, fond"
```
高级方法，字符序列，传入函数作为参数，实现更加精细的替换操作，详见高程128
```javascript
var text = 'cat, bat, sat, fat';
result = text.replace(/(.at)/g, 'word ($1)');
alert(result); //word (cat), word (bat), word (sat), word (fat)
```
```javascript
name = 'aaa bbb ccc';
uw=name.replace(/\b\w+\b/g, function(word){
  return word.substring(0,1).toUpperCase()+word.substring(1);
});
alert(um); //Aaa Bbb Ccc
```

```javascript
function htmlEscape(text) {
    return text.replace(/[<>"&]/g, function(match, pos, originText) {
        switch(match) {
            case "<":
                return "&lt;";
            case "<":
                return "&gt;";
            case "&":
                return "&amp;";
            case "\"":
                return "&quot;";
        }
    });
}

alert(htmlEscape("Dolce & Gabbana")); //Dolce &​amp; Gabbana
```

`split()`
```javascript
var colorText = 'red,blue,green,yellow';
var colors1 = colorText.split(','); //["red", "blue", "green", "yellow"]
var colors2 = colorText.split(",", 2); //["red", "blue"]
var colors = colorText.split(/[^\,]+/); //["", ",", ",", ",", ""]
```

关于`/[^\,]+/`表达式中的`\`，`,`虽然不是正则表达式中的元字符，这里使用`\`保险起见防止后面的字符被解析为其他含义。

字符串中单个`\`表示转义，要想表示`\`这个字符，需要使用`\\`。

##### `localeCompare()`方法
这个方法比较两个字符串，按字母表排序比较先后
```javascript
var stringValue = 'yellow';
alert(stringValue.localeCompare('brick')); //1
alert(stringValue.localeCompare('yellow')); //0
alert(stringValue.localeCompare('zoo')); //-1
```
#### Math对象
##### Math对象的属性
属性|说明
---|---
`Math.E`|自然对数的底数，即常量e的值
`Math.LN10`|10的自然对数
`Math.LN2`|2的自然对数
`Math.LOG2E`|以2为底e的对数
`Math.LOG10E`|以10为底e的对数
`Math.PI`|pi的值
`Math.SQRT1_2`|1/2的平方根（即2的平方根的倒数）
`Math.SQRT2`|2的平方根

##### `min()`和`max()`方法
```javascript
var max = Math.max(3, 54, 32, 16);
alert(max); //54

var min = Math.min(3, 54, 32, 16);
alert(min); //3
```
找到数组中的最大或最小值，这里`apply`的作用在于传参。
```javascript
var values = [1, 2, 3, 4, 5, 6, 7, 8];
var max = Math.max.apply(Math, values);
```

##### 舍入方法
+ `Math.ceil()`执行向上舍入
+ `Math.floor()`执行向下舍入
+ `Math.round()`执行标准舍入

```javascript
alert(Math.ceil(25.9)); //26
alert(Math.ceil(25.5)); //26
alert(Math.ceil(25.1)); //26

alert(Math.round(25.9)); //26
alert(Math.round(25.5)); //26
alert(Math.round(25.1)); //25

alert(Math.floor(25.9)); //25
alert(Math.floor(25.5)); //25
alert(Math.floor(25.1)); //25
```

##### `random()`方法
`Math.random()`返回一个大于等于0小于1的随机数。

`var num = Math.floor(Math.random() * 10 + 1); //选择一个1到10之间的数值`

`var num = Math.floor(Math.random() * 9 + 2); //选择一个2到10之间的数值`

```javascript
function selectFrom(lowerValue, upperValue) {
    var choices = upperValue - lowerValue +1;
    return Math.floor(Math.random() * choices + lowerValue); 
}

var num = selectFrom(2, 10);
alert(num); //介于2和10之间的一个数值
```

```javascript
var colors = ['red', 'green', 'blue', 'yellow', 'black', 'purple', 'brown'];
var color = colors[selectFrom(0, colors.length)];
alert(color); //可能是数组中包含的任何一个字符串
```

##### 其他方法
方法|说明
---|---
`Math.abs(num)`|返回num的绝对值
`Math.exp(num)`|返回Math.E的num次幂
`Math.log(num)`|返回num的自然对数
`Math.pow(num,power)`|返回num的power次幂
`Math.sqrt(num)`|返回num的平方根
`Math.acos(x)`|返回x的反余弦值
`Math.asin(x)`|返回x的反正弦值
`Math.atan(x)`|返回x的反正切值
`Math.atan2(y,x)`|返回y/x的反正弦值
`Math.cos(x)`|返回x的余弦值
`Math.sin(x)`|返回x的正弦值
`Math.tan(x)`|返回x的正切值

## chap6.面向对象的程序设计
ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数”。
### 理解对象
创建自定义对象最简单的方式就是创建一个Object实例，然后再为他们添加属性和方法
```javascript
var person = new Object();
person.name = 'Nicholas';
person.age = 29;
person.job = 'Software Engineer';

person.sayName = function() {
    alert(this.name);
}
```

用字面量语法可以写成这样：
```javascript
var person = {
    name: 'Nicholas',
    age: 29,
    job: 'Software Engineer',

    sayName: function() {
        alert(this.name);
    }
};
```
#### 属性类型
ECMAScript中有两种属性：数据属性和访问器属性。
1. 数据属性
+ Configurable 可否通过delete删除,能否修改其他数据属性
+ Enumerable 这个属性是否可以通过for-in循环出来
+ Writable 能否修改属性的值
+ Value 这个属性的值
```javascript
var person = {};
Object.defineProperty(person, 'name', {
    configurable: false,
    value: 'Nicholas'
});

alert(person.name); //"Nicholas"
delete person.name; 
alert(person.name); //"Nicholas"
```
把`configurable`设置为`false`,不能从对象中删除属性,一旦把属性定义为`configurable: false`,就不可以再变回`configurable`

2. 访问器属性
访问器属性不包含数据值，包含一对`getter`、`setter`函数，不可以直接定义，必须使用`Object.defineProperty()`来定义。包含如下4个特性。
+ Configurable
+ Enumerable
+ Get
+ Set
```javascript
var book = {
    _year: 2004,
    edition: 1
};

Object.defineProperty(book, 'year', {
    get: function() {
        return this._year;
    },
    set: function(newValue) {
        if (newValue) {
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
});

book.year = 2005;
alert(book.edition); //2
```
_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。

使用`Object.defineProperties()`方法来一次性定义多个属性,`Object.getOwnPropertyDescriptor()`取得给定属性的描述符。

```javascript
var book = {};

Object.defineProperties(book, {
    _year: {
        writable: true,
        value: 2004
    },

    edition: {
        writable: true,
        value: 1
    },

    year: {
        get: function() {
            return this._year;
        },

        set: function() {
            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
});
```

### 创建对象
**1. 工厂模式**
```javascript
function createPerson(name,age,job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function() {
        alert(this.name);
    };
    return o;
}

var person1 = createPerson('Nicholas', '29', 'Software Engineer');
var person2 = createPerson('Greg', '27', 'Doctor');
```
解决了创建多个相似对象的问题，但没有解决对象识别的问题（即怎样知道一个对象的类型）

**2. 构造函数模式**

使用构造函数模式重写前面例子
```javascript
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        alert(this.name);
    };
}

var person1 = new Person('Nicholas', '29', 'Software Engineer');
var person2 = new Person('Greg', '27', 'Doctor');
```
函数名`Person`使用的是大写字母。按照惯例，构造函数始终都应该以一个大写字母开头，非构造函数则应该以一个小写字母开头。

创建`Person`新实例，必须使用`new`操作符，否则跟普通函数不会有什么两样

new操作符构造函数实际经历以下4个步骤：
> 1. 创建一个新对象；
> 2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
> 3. 执行构造函数中的代码（为这个新对象添加属性）；
> 4. 返回新对象。

MDN上对new foo(...)执行的解释
>1. 一个新对象被创建。它继承自foo.prototype.
>2. 构造函数 foo 被执行。执行的时候，相应的参数会被传入，同时上下文(this)会被指定为这个新实例。new foo 等同于 new foo(), 只能用在不传递任何参数的情况。
>3. 如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象，ps：一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。

#### 将构造函数当做函数

任何函数，只要通过`new`操作符来调用，就可以作为构造函数
```javascript
// 当做构造函数使用
var person = new Person('Nicholas', 29, 'Software Engineer');
person.sayName(); //"Nicholas"

// 作为普通函数调用
Person('Greg', 27, 'Doctor'); //添加到window
window.sayName(); //"Greg"

//在另一个对象的作用域中调用
var o = new Object();
Person.call(o, 'Kristen', '25', 'Nurse');
o.sayName(); //'Kristen'
```
不使用`new`操作符会导致属性和方法都被添加到了Global对象上。

构造函数的主要问题是每个方法都要在每个实例上重新创建一遍

**3. 原型模式**
```javascript
function Person() {
}

Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
    alert(this.name);
};

var person1 = new Person();
person1.sayName(); //'Nicholas'

var person2 = new Person();
person2.sayName(); //'Nicholas'

alert(person1.sayName == person2.sayName); //true
```
1. 理解原型对象

只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个`peototype`属性，这个属性是一个指针，指向函数的原型对象。

`isPrototype()`方法来确定对象之间原型关系
```javascript
alert(Person.prototype.isPrototypeOf(person1)); //true
alert(Person.prototype.isPrototypeOf(person2)); //true
```
ECMAScript5中增加`Object.getPrototypeOf()`，返回[[Prototype]]的值。
```javascript
alert(Object.getPrototypeOf(person1) == Person.prototype); //true

alert(Object.getPrototypeOf(person1).name); //'Nicholas'
```

`delete`操作符可以完全删除实例属性，从而可以直接访问原型中的属性
```javascript
function Person() {
}

Person.protytype.name = 'Nicholas';
Person.protytype.age = 29;
Person.protytype.job = 'Software Engineer';
Person.protytype.sayName = function() {
    alert(this.name);
}

var person1 = new Person();
var person2 = new Person();

person1.name = 'Greg';
alert(person1.name); //"Greg"---来自实例
alert(person2.name); //"Nicholas"---来自原型

delete person1.name;
alert(person1.name); //"Nicholas"---来自原型
```

使用`hasOwnProperty()`方法检测一个属性是否存在于实例中，还是存在于原型中。只有给定属性存在于对象实例中，才会返回`true`。

2. `in`操作符

`in`操作符会在通过对象能够访问给定属性时返回`true`，无论该属性存在于实例还是原型中。
`'name' in person1; //true`

```javascript
function hasPrototypeProperty(object, name) {
    return !object.hasOwnProperty(name) && (name in object);
}
```
这个函数可以检测对象中的属性是否仅存在于原型中

`Object.keys()`接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。
```javascript
function Person() {
}

Person.protytype.name = 'Nicholas';
Person.protytype.age = 29;
Person.protytype.job = 'Software Engineer';
Person.protytype.sayName = function() {
    alert(this.name);
};

var keys = Object.keys(Person.prototype);
alert(keys); //"name,age,job,sayName"

var p1 = new Person();
p1.name = 'Rob';
p1.age = 31;
var p1keys = Object.keys(p1);
alert(p1keys); //"name,age"
```

3. 更简单的原型语法

更简单的原型语法,字面量形式，实际上重写了原型对象，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的任然是最初的原型。
```javascript
Person.prototype = {
    name : 'Nicholas',
    age : 29,
    job : 'Software Engineer',
    sayName : function() {
        alert(this.name);
    }
};
```

每创建一个函数，同时会创建它的`prototype`对象，这个对象自动获得`constructor`属性，这里的语法本质上重写了默认的`prototype`对象，因此`constructor`属性也就变成了新对象的`constructor`属性（指向`Object`构造函数），不再指向`Person`函数。

如果`constructor`属性很重要，可以显示指定。
```javascript
function Person() {
}

Person.prototype = {
    constructor : Person,
    name : 'Nicholas',
    age : 29
};
```

4. 原型的动态性

实例中的指针仅指向原型对象，而不指向构造函数。

重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。

5. 原型对象的问题

```javascript
function Person() {    
}

Person.prototype = {
    constructor : Person,
    name : 'Nicholas',
    age : 29,
    job : 'Software Engineer',
    friends : ['Shelby','Court'],
    sayName : function() {
        alert(this.name);
    }
};

var person1 = new Person();
var person2 = new Person();

person1.friends.push('Van');

alert(person1.friends); //"Shelby,Court,Van"
alert(person2.friends); //"Shelby,Court,Van"
alert(person1.friends === person2.friends); //true
```
> 1. 省略了为构造函数传递初始化参数这一环节，所有实例默认情况下都取得相同的属性值
> 2. 原型中的所有属性被很多实例共享，由于friends数组存在于Person.prototype而非person1中，所以person1的push('Van')在person2中也会反映出来

实例上访问原型对象的属性，如果是引用类型的属性比如数组，实例上访问的是该数组的引用，任何操作都会发生改变

**4. 组合使用构造函数模式和原型模式**
```javascript
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ['Shelby', 'Court']
}

Person.prototype = {
    constructor : Person,
    sayName : function() {
        alert(this.name);
    }
}

var person1 = new Person('Nicholas', 29, 'Software Engineer');
var person2 = new Person('Greg', 27, 'Doctor')

person1.friends.push('Van');
alert(person1.friends); //"Shelby,Count,Van"
alert(person2.friends); //"Shelby,Count"
alert(person1.friends === person2.friends); //false
alert(person1.sayName === person2.sayName); //true
```
使用构造函数就是在实例上创建构造函数中的属性

**5.动态原型模式**
将所有信息都封装在构造函数中，在构造函数中初始化原型
```javascript
function Person() {

    //属性
    this.name = name;
    this.age = age;
    this.job = job;

    //方法
    if (typeof this.sayName != 'function') {
        Person.prototype.sayName = function() {
            alert(this.name);
        };
    }
}
```
**6.寄生构造函数模式**

寄生的意思就是增强创建出来的对象

基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。除了使用`new`操作符以外，这个模式与工厂模式其实是一模一样的。构造函数在不返回值得情况下，默认会返回新对象实例。通过在构造函数的末尾添加一个`return`语句，可以重写调用构造函数时返回的值。

假设我们想创建一个具有额外方法的特殊数组，由于不能直接修改`Array`构造函数，因此使用这个模式。
```javascript
function SpecialArray() {

    //创建数组
    var values = new Array();

    //添加值
    values.push.apply(values, arguments);

    //添加方法
    values.toPipedString = function() {
        return this.join('|');
    };

    //返回数组
    return values;
}

var colors = new SpecialArray('red', 'blue', 'green');
alert(colors.toPipedString()); //"red|blue|green"
```

### 继承

许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，依靠原型链实现。

**1. 原型链继承**
```javascript
function SuperType() {
    this.property = true;
}

SuperType.prototype.getSuperValue = function() {
    return this.perperty;
};

function SubType() {
    this.subproperty = false;
}

//继承了SuperType
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function() {
    return this.subproperty;
}

var instance = new SubType();
alert(instance.getSuperValue()); //true
```
> 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象

原型链继承的本质是重写原型对象，代之以一个新类型的实例

所有的函数的默认原型都是Object的实例，因此默认原型会包含一个内部指针，指向Object.prototype

确定原型和实例的关系`instanceof`操作符，`isPrototypeOf()`方法。
```javascript
alert(instance instanceof Object);
alert(Object.prototype.isPrototypeOf(instance));
```

给原型添加方法的代码一定要放在替换原型的语句之后

原型链的问题
```javascript
function SuperType() {
    this.colors = ['red', 'blue', 'green'];
}

function SubType() {
}

//继承了 SuperType
SubType.prototype = new SuperType();

var instance1 = new SubType();
instance1.colors.push('black');
alert(instance1.colors); //"red,blue,green,black"

var instance2 = new SubType();
alert(instance2.colors); //"red,blue,green,black"
```
原先的实例属性变成了现在的原型属性，不能向超类型的构造函数中传递参数

**2. 借用构造函数**
```javascript
function SuperType() {
}

function SubType() {
    //继承了SuperType
    SuperType.call(this);
}

var instance1 = new SubType();
instance1.colors.push('black');
alert(instance1.colors); //"red,blue,green,black"

var instance2 = new SubType();
alert(instance2.colors); //"red,blue,green"
```
call和apply是为了动态改变this而出现的，当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。

实际上是在将要创建的SubType实例环境中调用了SuperType构造函数，这样一来就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。这样SubType每个实例就会有自己colors属性副本了。

借用构造函数还可以传递参数
```javascript
function SuperType(name) {
    this.name = name;
}

function SubType() {
    //继承了SuperType,同时还传递了参数
    SuperType.call(this,'Nicholas');

    //实例属性  
    this.age = 29;
}

var instance = new SubType();
alert(instance.name); //"Nicholas";
alert(instance.age); //29

var instance1 = new SubType();
alert(instance1.age);
```
借用构造函数的问题：方法都在构造函数中，做不到函数复用。

**3. 组合继承**

背后的思路是使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。

在原型上定义方法实现函数复用，又保证每个实例都有自己的属性。

```javascript
function SuperType(name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

SuperType.prototype.sayName = function() {
    alert(this.name);
}

function SubType(name,age) {
    //继承属性
    SuperType.call(this,name,age);
    this.age = age;
}

SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function() {
    alert(this.age);
};

var instance1 = new SubType('Nicholas','29');
instance1.colors.push('black');
alert(instance1.colors); //"red,blue,green,black"
instance1.sayName(); //"Nicholas"
instance1.sayAge(); //29

var instance2 = new SubType('Greg','27');
alert(instance2.colors); //"red,blue,green"
instance2.sayName(); //"Greg"
instance2.sayAge(); //27
```

**4.原型式继承**

```javascript
function object(o) {
    function F() {};
    F.prototype = o;
    return new F();
}
```

```javascript
var person = {
    name: 'Nicholas',
    friend: ['Shelby', 'Court', 'Van']
};

var anotherPerson = object(person);
anotherPerson.name = 'Greg';
anotherPerson.friends.push('Rob');

var yetAnotherPerson = object(person);
yetAnotherPerson.name = 'Linda';
yetAnotherPerson.friends.push('Barbie');

alert(person.friends); //"Shelby,Court,Van,Rob,Barbie"
```

ECMAscript5新增`Object.create()`方法规范了原型式继承。传入一个参数的情况下，`Object.create()`与`object()`方法行为相同。
```javascript
var person = {
    name: 'Nicholas',
    friend: ['Shelby', 'Court', 'Van']
};

var anotherPerson = Object.create(person);
anotherPerson.name = 'Greg';
anotherPerson.friends.push('Rob');

var yetAnotherPerson = Object.create(person);
yetAnotherPerson.name = 'Linda';
yetAnotherPerson.friends.push('Barbie');

alert(person.friends); //"Shelby,Court,Van,Rob,Barbie"
```
`Object.create()`方法第二个参数与`Object.defineProperties()`第二个参数格式相同。

**5.寄生式继承**
```javascript
function createAnother(original) {
    var clone = object(original); //通过调用函数创建一个新对象
    clone.sayHi = function() { //以某种方式来增强这个对象
        alert('hi');
    };
    return clone; //返回这个对象
}
```

```javascript
var person = {
    name: 'Nicholas',
    friends: ['Shelby', 'Court', 'Van']
};

var anotherPerson = createAnother(person);
anotherPrson.sayHi(); //"hi"
```

> 使用寄生式继承做不到函数复用，效率不高

**6.寄生组合式继承**

组合继承的不足在于，无论什么情况下，都会调用两次超类型构造函数

寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。不必为了指定子类型的原型而调用超类型构造函数。

```javascript
function inheritPrototype(subType, superType) {
    var prototype = object(superType.prototype); //创建对象，返回的是superType.prototype的实例
    prototype.constructor = subType; //增强对象
    subType.prototype = prototype; //指定对象
}
```

```javascript
function SuperType(name) {
    this.name = name;
    this.color = ['red', 'blue', 'green'];
}

SuperType.prototype.sayName = function() {
    alert(this.name);
};

function SubType(name, age) {
    SuperType.call(this, name);

    this.age = age;
}

inheritPrototype(SubType, SuperType);

SubType.ptototype.sayAge = funciton() {
    alert(this.age);
};
```
这种方式的高效在于只调用了一次`SuperType`构造函数，因此避免了在`SubType.prorotype`上面创建不必要的、多余的属性。与此同时，原型链还能保持不变。

### 总结
#### 创建对象的模式
1. 工厂模式

在函数中创建对象，为对象添加属性和方法，然后return这个对象。

2. 构造函数模式

创建自定义引用类型，使用new操作符。缺点是每个成员无法得到复用，包括函数。

3. 原型模式

使用构造函数的`prototype`属性来指定那些共享的属性和方法。组合使用构造函数模式和原型模式，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。

#### 继承
使用最多的继承模式式组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。

1. 原型式继承

本质是执行对给定对象的浅复制

2. 寄生式继承

与原型式继承非常相似，复制对象之后进行增强对象的操作

3. 寄生组合式继承

集寄生式继承和组合继承的有点于一身，解决了组合继承模式由于多次调用超类型构造函数而导致的低效率问题

## 函数表达式

+ 函数表达式的特征
+ 使用函数实现递归
+ 使用闭包定义私有变量

函数声明的重要特性就是函数声明提升(function declaration hoisting)
```javascript
sayHi();
function sayHi() {
    alert("Hi!");
}
```
第二种创建函数的方式是使用函数表达式
```javascript
var functionName = function(arg0, arg1, arg2) {
    //函数体
}
```
创建一个函数并将其赋给变量functionName，这种情况下创建的函数叫做匿名函数(anonymous function)，因为`fucntion`关键字后面没有标识符。（匿名函数有时候也叫做拉达姆函数）

1. 递归

`arguments.callee`是一个指向正在执行函数的指针
```javascript
function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}
```

2. 闭包（Closure）

**闭包**是指有权访问另一个函数作用域中的变量的函数。
```javascript
function createComparisonFunction(propertyName) {
    return function(object1, object2) {
        var value1 = object1[propertyName]; //
        var value2 = object2[propertyName]; //
        
        if (value1 < value2) {
           return -1; 
        } else if (value1 > value2) {
            return 1;
        } else {
            return 0;
        }
    };
}
```
这个例子中，"//"标记的那两行是内部（一个匿名函数）中的代码，这两行代码访问了外部函数中的变量`propertyName`。即使这个函数被返回了，在其他地方被调用，仍可以访问这个变量，因为函数内部作用域链中包含`createComparisonFunction()`的作用域。

```javascript
function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value1 > value2) {
        return 1;
    } else {
        return 0;
    }
}

var result = compare(5, 10);
```

后台的每个执行环境都有一个表示变量的对象---变量对象。全局环境的变量对象始终存在，而像`compare()`函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建`compare()`函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用`compare()`函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构件起执行环境的作用域链。

`compare`的执行环境-->作用域链-->变量对象

> 作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。

一般来讲，当函数执行完毕之后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)，但是，闭包的情况又有所不同。

在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。在`createComparisonFunction()`函数内部定义的匿名函数的作用域链中，实际上会包含外部函数`createComparisonFunction()`的活动对象。

`createComparisonFunction()`函数在执行完毕后，其活动对象不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。直到匿名函数被销毁后，`createComparisonFunction()`的活动对象才会被销毁

```javascript
//创建函数
var compareNames = createComparisonFunction('name');

//调用函数
var result = compareNames({name : 'Nicholas'}, {name : 'Greg'});

//解除对匿名函数的引用（以便释放内存）
compareNames = null;
```

### 执行上下文

+ 执行上下文（Execution Context）
    + 单线程
    + 同步执行
    + 只有一个全局上下文
    + 可有无数个函数上下文
    + 每个函数调用都会创建一个新的执行上下文，哪怕是递归调用

就是当前代码的执行环境/作用域，有全局环境，和函数（局部）环境，`eval`暂时不讨论

+ 执行栈（Execution Context Stack）

浏览器第一次加载脚本, 它将默认进入全局执行上下文中。如果,你在全局环境中调用了一个函数, 你的程序序列流会进入被调用的函数的当中，创建一个新的执行上下文并且将这个上下文压入执行栈之中。

+ 活动对象/变量对象（AO/VO）

每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。如果这个执行环境是函数，则将其活动对象（activation object）作为变量对象。

#### 执行上下文中的细节
1. 创建阶段（当函数被调用，内部的代码还没开始执行）：
2. 创建作用域链
3. 创建变量、函数以及参数
4. 决定`this`的值
5. 激活、代码执行阶段：
6. 赋值，寻找函数引用以及解释/执行代码

这是解释器执行代码时的伪概述:

1. 寻找调用函数的代码
2. 在执行函数代码之前, 创建执行上下文.
3. 进入创建阶段:
4. 初始化 作用域链.
5. 创建变量对象：
6. 创建参数对象, 检查参数的上下文,初始化其名称和值并创建一个引用拷贝。
7. 扫描上下文中的函数声明：
8. 对于每个被发现的函数, 在变量对象中创建一个和函数名同名的属性，这是函数在内存中的引用。
9. 如果函数名已经存在,引用值将会被覆盖。
10. 扫描上下文中的变量声明：
11. 对于每个被发现的变量声明,在变量对象中创建一个同名属性并初始化值为undefined。
12. 如果变量名在变量对象中已经存在, 什么都不做，继续扫描。
13. 确定上下文中的"this"
14. 激活 / 代码执行阶段：
15. 执行 / 在上下文中解释函数代码，并在代码逐行执行时给变量赋值。

```javascript
function foo(i) {
    var a = 'hello';
    var b = function privateB() {

    };
    function c() {

    }
}

foo(22);
```
在调用foo(22)的时候, 创建阶段看起来像是这样:
```javascript
fooExecutionContext = {
    scopeChain: { ... },
    variableObject: {
        arguments: {
            0: 22,
            length: 1
        },
        i: 22,
        c: pointer to function c()
        a: undefined,
        b: undefined
    },
    this: { ... }
}
```
激活 / 代码 执行阶段看起来像是这样：
```javascript
fooExecutionContext = {
    scopeChain: { ... },
    variableObject: {
        arguments: {
            0: 22,
            length: 1
        },
        i: 22,
        c: pointer to function c()
        a: 'hello',
        b: pointer to function privateB()
    },
    this: { ... }
}
```
#### 立即执行函数
> Javascript语言精粹：
表达式是由运算符构成，并运算产生结果的语法结构。
程序是由语句构成，语句则是由“；（分号）”分隔的句子或命令。
如果在表达式后面加上一个“；”分隔符，这就被称为“表达式语句”。它表明“只有表达式，而没有其他语法元素的语句”

```javascript
function() {
    //这里是函数作用域
}(); //出错！
```
JavaScript将`function`关键字当做一个函数声明的开始，而函数声明后面不能跟圆括号。

`!function(){alert('iifksp')}();   // true`

在控制台运行后得到的值时true，为什么是true这很容易理解，因为这个匿名函数没有返回值，默认返回的就是undefined，求反的结果很自然的就是true。

其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是让一个函数声明语句变成了一个表达式。

```javascript
var i = function(){return 10}(); // undefined  
1 && function(){return true}(); // true  
1, function(){alert('iifksp')}(); // undefined  
```
任何消除函数声明和函数表达式间歧义的方法，都可以被解析器正确识别。
```javascript
!function(){alert('iifksp')}()        // true
+function(){alert('iifksp')}()        // NaN
-function(){alert('iifksp')}()        // NaN
~function(){alert('iifksp')}()        // -1
```

##### 模拟块级作用域

使用匿名立即执行函数来模拟块级作用域
```javascript
(function() {
    var now = new Date();
    if (now.getMonth() == 0 && now.getDate() == 1) {
        alert('Happy new year!');
    }
})();
```
> 这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。

3. 闭包与变量

作用域链机制引出了一个副作用，即闭包只能取得包含函数中任何变量的最后一个值，因为闭包保存的是整个变量对象。
```javascript
function createFunctions() {
    var result = new Array();

    for (var i = 0; i < 10; i++) {
        result[i] = function() {
            return i;
        };
    }

    return result;
}
```

每个函数都返回10，因为每个函数的作用域链中都保存着`createFunctions()`函数的活动对象，所以他们引用的都是同一个变量`i`。当`createFunctions()`函数返回后，变量`i`的值是10，此时每个函数都引用着保存变量`i`的同一个变量对象，所以在每个函数每部`i`的值都是10。

通过创建另一个匿名函数强制让闭包的行为符合预期。

```javascript
function createFunctions() {
    var result = new Array();

    for (var i = 0; i < 10; i++) {
        result[i] = function(num) {
            return function() {
                return num;
            }
        }(i);
    }
}
```

闭包还可以这么理解
```javascript
function init() {
    var name = 'Mozilla';
    function displayName() {
        alert(name);
    }
    displayName();
}

init(); // "Mozilla"
```
```javascript
function makeFunc() {
    var name = 'Mozilla';
    function displayName() {
        alert(name);
    }
    return displayName;
}

var myFunc = makeFunc();
myFunc(); //"Mozilla"
```

4. 关于`this`对象

`this`对象是在运行时基于函数的执行环境绑定的：在全局函数中，`this`等于`window`，而当函数被作为某个对象的方法调用时，`this`等于那个对象。匿名函数的执行环境具有全局性，因此其`this`对象通常指向`window`。
```javascript
var name = 'The Window';

var object = {
    name : 'My Object',

    getNameFunc : function() {
        return function() {
            return this.name;
        };
    }
;}

alert(object.getNameFunc()()); //"The Window"
```

```javascript
var name = 'The Window';

var object = {
    name : 'My Object',

    getNameFunc : function() {
        var that = this;
        return function() {
            return that.name;
        };
    }
;}

alert(object.getNameFunc()()); //"My Object"
```

保存一下`this`，可以通过闭包访问

```javascript
var name = "The Window";
var object = {
    name : "My Object",
    getName: function(){
         return this.name;
    }
};
(object.getName = object.getName)(); //"The Window" 
```
如何理解这个输出结果？
```javascript
var _func = object.getName
_func()
```
`object.getName = object.getName`这是一个表达式

这段表达式的作用是：为`object`设置`getName`属性（方法）。这段表达式运行后返回了一个返回值，即后面那部分（object.getName）的值，也就是这个函数了。把函数括起来，再在后面加一对括号，就是执行这个函数。

# chap13.事件

## 事件流

事件流是描述从页面中接收时间的顺序，IE的事件流是事件冒泡流，而Netscape的事件流是时间捕获流。

### 事件冒泡(event bubbling)

事件开始时由最具体的元素接收，逐级向上传播到较为不具体的节点。

### 事件捕获(event capturing)

事件捕获的思想是不太具体的节点更早接收到事件，而最具体的节点最后接收到时间。

### DOM事件流

"DOM2级事件"规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。

## 事件处理程序

### HTML事件处理程序

```html
<input type="button" value="Click me" onclick="alert('Clicked')">
```

`onclick`的值是`javascript`代码。

缺点:
1. 存在时差，事件处理程序可能不具备执行条件
2. 作用域链在不同浏览器中不同
3. HTML与JavaScript紧密耦合


### DOM0级事件处理程序

```javascript
var btn = document.getElementById('myBtn');
btn.onclick = function() {
    alert('Clicked');
};
```

> 使用DOM0级方法指定的事件处理程序被认为是元素的方法。

这种方式添加的时间处理程序会在事件流的冒泡阶段被处理。

`btn.onclick = null; //删除事件处理程序`

### DOM2级事件处理程序

定义了两个方法
1. `addEventListener()`
2. `removeEventListener()`

所有DOM节点都包含这两个方法，三个参数：
1. 要处理的事件名
2. 作为事件处理程序的函数
3. `true`表示在捕获阶段调用事件处理程序；`false`表示在冒泡阶段调用事件处理程序

```javascript
var btn = document.getElementById('myBtn');
btn.addEventListener('click', function() {
    alert('Hello world!');
}, false);
```

与DOM0级相同，这种方式添加的事件处理程序也是在其依附的作用域中运行，使用DOM2级方法添加事件处理程序的好处在于可以添加多个事件处理程序。

```javascript
var btn = document.getElementById('myBtn');

btn.addEventListener('click', function() {
    alert(this.id);
}, false);

btn.addEventListener('click', function() {
    alert('Hello world!');
}, false);
```

通过`addEventListener()`添加的事件处理程序只能使用`removeEventListener()`来移除；移除时传入参数与添加时相同，这意味着通过`addEventListener()`添加的匿名函数将无法移除。

```javascript
var btn = document.getElementById('myBtn');
var handler = function() {
    alert(this.id);
}

btn.addEventListener('click', handler
}, false);

btn.removeEventListener('click', handler
}, false); //有效!
```

### IE事件处理程序

IE实现了类似于DOM的两个方法
1. `attachEvent()`
2. `detachEvent()`

```javascript
var btn = document.getElementById('myBtn');
btn.attachEvent('onclick', function() {
    alert('Clicked');
});
```
都是传入两个参数，事件处理程序名称与事件处理函数。

> `attachEvent()`的第一个参数是’onclick’，而非DOM的`addEventListener()`方法中的'click'。

`attachEvent()`事件处理程序会在全局作用域中运行，this等于window

> 支持IE事件处理程序的浏览器有IE和Oprea

### 跨浏览器的事件处理程序

```javascript
var EventUtil = {

	addHandler: function(element, type, handler) {
		if (element.addEventListener) {
			element.addEventListener(type, handler, false);
		} else if (element.attachEvent) {
			element.attachEvent('on' + type, handler);
		} else {
			element['on' + type] = handler;
		}
	},
	removeHandler: function(element, type, handler) {
		if (element.removeEventListener) {
			element.removeEventListener(type, handler, false);
		} else if (element.detachEvent) {
			element.detachEvent('on' + type, handler);
		} else {
			element['on' + type] = null;
		}
	}
}
```

## 事件对象

> 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件相关的信息。

### DOM中的事件对象

无论指定事件处理程序用什么方法，都会传入`event`对象，即使没有显式传入`event`参数。

```javascript
var btn = document.getElementById('myBtn');
btn.onclick = function() {
    alert(event.type); //"click"
}
btn.addEventListener('click', function(event) {
    alert(event.type); //"click"
}, false);
```

event对象简要属性/方法
属性/方法|类型|说明
---|---|---
cancelable|Boolean|表明是否可以取消事件的默认行为
currentTarget|Boolean|其事件处理程序正在处理事件的那个元素
eventPhase|Integer|调用事件处理程序的阶段：1表示捕获阶段，2表示“处于目标”，3表示“冒泡阶段”
preventDefault()|Function|取消事件的默认行为
stopPropagation()|Funciton|取消事件的进一步捕获或冒泡
target|Element|事件的目标
type|String|被触发事件的类型

在事件处理程序内部，对象`this`的值式中等于`currentTarget`的值，而`target`则只包含事件的实际目标。

通过一个函数处理多个事件，可以使用`type`属性

```javascript
var btn = document.getElementById('myBtn');
var handler = function(event) {
    switch(event.type) {
        case 'click':
            alert('Clicked');
            break;

        case 'mouseover':
            event.target.style.backgroundColor = 'red';
            break;

        case 'mouseout';
            event.target.style.backgroundColor = '';
            break;
    }
};

btn.onclick = handler;
btn.onmouseover = handler;
btn.onmouseout = handler;
```