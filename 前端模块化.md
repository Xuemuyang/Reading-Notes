# JavaScript模块化思想

## 模块的写法

1.原始写法

模块就是实现特定功能的一组方法

```js
function m1() {
    //...
}

function m2() {
    //...
}
```

这种做法污染全局变量。

2.对象写法

```js
var module1 = new Object({
    _count : 0,

    m1: function() {
        //...
    },

    m2: function() {
        //...
    }
})
```

这种写法会暴露所有模块成员

3.立即执行函数写法(Immediately-Invoked Function Expression, IIFE)

```js
var module1 = (function() {
    var _count = 0;

    var m1 = function() {
        //...
    };

    var m2 = function() {
        //...
    };

    return {
        m1 : m1,
        m2 : m2
    };
})
```

使用这种写法，外部代码无法读取内部`_count`变量。

4.放大模式(augmentation)

一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块。

```js
var module1 = (function(mod) {

    mod.m3 = function() {
        //...
    };

    return mod;

})(module1);
```

5.宽放大模式(Loose augmentation)

在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用"宽放大模式"。

```js
var module1 = (function(mod) {
    //...
    return mod;
})(window.module1 || {})
```

6.输入全局变量

为了在模块内部调用全局变量，显式地将其他变量输入模块。

```js
var module1 = (function($, YAHOO) {
    //...
})(jQuery, YAHOO);
```

7.模块的规范

有了模块，就可以更方便的使用别人的代码，想要什么功能就加载什么模块。

前提是大家必须遵守一套规范。

通行的JS模块规范有`CommonJS`和`AMD`

8.CommonJS

`Node.js`诞生标志JS模块化编程诞生

服务器端一定要有模块

CommonJS中有一个全局性方法`require()`，用于加载模块。假定有一个数学模块math.js，可以像下面这样加载。

```js
var math =  require('math');
math.add(2, 3);
```

9.浏览器环境

服务器端模块都存放在本地硬盘，可以同步加载，对于浏览器只能采用“异步加载”(asynchronous)。这就是AMD规范诞生的背景。

10.AMD

`Asynchronous Module Definition`

采用异步加载模块，所有依赖这个模块的语句，都定义在回调函数中，等到加载完成之后，这个回调函数才会运行。

```js
require(['math'], function(math) {
    math.add(2, 3);
});
```

`require.js`实现了`AMD`规范。

## require.js的用法

1.为什么使用

最早的时候，所有的JS代码都写在一个文件里，后来代码越来越多需要分成多个文件依次加载。

加载的时候浏览器会停止网页渲染，加载文件越多，网页失去响应时间就越长；JS文件之间存在依赖关系，必须严格保证加载顺序，依赖性最大的模块一定要放在最后加载。

于是有了`require.js`。

它的诞生为了解决两个问题：

1. 实现JS文件的异步加载，避免网页失去响应;
1. 管理模块之间的依赖性，便于代码的编写和维护。

