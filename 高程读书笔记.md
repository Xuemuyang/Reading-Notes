## chap6.面向对象的程序设计
ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数”。
### 理解对象
创建自定义对象最简单的方式就是创建一个Object实例，然后再为他们添加属性和方法
```
var person = new Object();
person.name = 'Nicholas';
person.age = 29;
person.job = 'Software Engineer';

person.sayName = function() {
    alert(this.name);
}
```

用字面量语法可以写成这样：
```
var person = {
    name: 'Nicholas',
    age: 29,
    job: 'Software Engineer',

    sayName: function() {
        alert(this.name);
    }
};
```
#### 属性类型
ECMAScript中有两种属性：数据属性和访问器属性。
1. 数据属性
+ Configurable 可否通过delete删除,能否修改其他数据属性
+ Enumerable 这个属性是否可以通过for-in循环出来
+ Writable 能否修改属性的值
+ Value 这个属性的值
```
var person = {};
Object.defineProperty(person, 'name', {
    configurable: false,
    value: 'Nicholas'
});

alert(person.name); //"Nicholas"
delete person.name; 
alert(person.name); //"Nicholas"
```
把`configurable`设置为`false`,不能从对象中删除属性,一旦把属性定义为`configurable: false`,就不可以再变回`configurable`

2. 访问器属性
访问器属性不包含数据值，包含一对`getter`、`setter`函数，不可以直接定义，必须使用`Object.defineProperty()`来定义。包含如下4个特性。
+ Configurable
+ Enumerable
+ Get
+ Set
```
var book = {
    _year: 2004,
    edition: 1
};

Object.defineProperty(book, 'year', {
    get: function() {
        return this._year;
    },
    set: function(newValue) {
        if (newValue) {
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
});

book.year = 2005;
alert(book.edition); //2
```
_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。

使用`Object.defineProperties()`方法来一次性定义多个属性,`Object.getOwnPropertyDescriptor()`取得给定属性的描述符。

```
var book = {};

Object.defineProperties(book, {
    _year: {
        writable: true,
        value: 2004
    },

    edition: {
        writable: true,
        value: 1
    },

    year: {
        get: function() {
            return this._year;
        },

        set: function() {
            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
});
```

### 创建对象
**1. 工厂模式**
```
function createPerson(name,age,job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function() {
        alert(this.name);
    };
    return o;
}

var person1 = createPerson('Nicholas', '29', 'Software Engineer');
var person2 = createPerson('Greg', '27', 'Doctor');
```
解决了创建多个相似对象的问题，但没有解决对象识别的问题（即怎样知道一个对象的类型）

**2. 构造函数模式**

使用构造函数模式重写前面例子
```
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        alert(this.name);
    };
}

var person1 = new Person('Nicholas', '29', 'Software Engineer');
var person2 = new Person('Greg', '27', 'Doctor');
```
函数名`Person`使用的是大写字母。按照惯例，构造函数始终都应该以一个大写字母开头，非构造函数则应该以一个小写字母开头。

创建`Person`新实例，必须使用`new`操作符，否则跟普通函数不会有什么两样

new操作符构造函数实际经历以下4个步骤：
> 1. 创建一个新对象；
> 2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
> 3. 执行构造函数中的代码（为这个新对象添加属性）；
> 4. 返回新对象。

MDN上对new foo(...)执行的解释
>1. 一个新对象被创建。它继承自foo.prototype.
>2. 构造函数 foo 被执行。执行的时候，相应的参数会被传入，同时上下文(this)会被指定为这个新实例。new foo 等同于 new foo(), 只能用在不传递任何参数的情况。
>3. 如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象，ps：一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。

#### 将构造函数当做函数

任何函数，只要通过`new`操作符来调用，就可以作为构造函数
```
// 当做构造函数使用
var person = new Person('Nicholas', 29, 'Software Engineer');
person.sayName(); //"Nicholas"

// 作为普通函数调用
Person('Greg', 27, 'Doctor'); //添加到window
window.sayName(); //"Greg"

//在另一个对象的作用域中调用
var o = new Object();
Person.call(o, 'Kristen', '25', 'Nurse');
o.sayName(); //'Kristen'
```
不使用`new`操作符会导致属性和方法都被添加到了Global对象上。

构造函数的主要问题是每个方法都要在每个实例上重新创建一遍

**3. 原型模式**
```
function Person() {
}

Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
    alert(this.name);
};

var person1 = new Person();
person1.sayName(); //'Nicholas'

var person2 = new Person();
person2.sayName(); //'Nicholas'

alert(person1.sayName == person2.sayName); //true
```
1. 理解原型对象

只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个`peototype`属性，这个属性是一个指针，指向函数的原型对象。

`isPrototype()`方法来确定对象之间原型关系
```
alert(Person.prototype.isPrototypeOf(person1)); //true
alert(Person.prototype.isPrototypeOf(person2)); //true
```
ECMAScript5中增加`Object.getPrototypeOf()`，返回[[Prototype]]的值。
```
alert(Object.getPrototypeOf(person1) == Person.prototype); //true

alert(Object.getPrototypeOf(person1).name); //'Nicholas'
```

`delete`操作符可以完全删除实例属性，从而可以直接访问原型中的属性
```
function Person() {
}

Person.protytype.name = 'Nicholas';
Person.protytype.age = 29;
Person.protytype.job = 'Software Engineer';
Person.protytype.sayName = function() {
    alert(this.name);
}

var person1 = new Person();
var person2 = new Person();

person1.name = 'Greg';
alert(person1.name); //"Greg"---来自实例
alert(person2.name); //"Nicholas"---来自原型

delete person1.name;
alert(person1.name); //"Nicholas"---来自原型
```

使用`hasOwnProperty()`方法检测一个属性是否存在于实例中，还是存在于原型中。只有给定属性存在于对象实例中，才会返回`true`。

2. `in`操作符

`in`操作符会在通过对象能够访问给定属性时返回`true`，无论该属性存在于实例还是原型中。
`'name' in person1; //true`

```
function hasPrototypeProperty(object, name) {
    return !object.hasOwnProperty(name) && (name in object);
}
```
这个函数可以检测对象中的属性是否仅存在于原型中

`Object.keys()`接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。
```
function Person() {
}

Person.protytype.name = 'Nicholas';
Person.protytype.age = 29;
Person.protytype.job = 'Software Engineer';
Person.protytype.sayName = function() {
    alert(this.name);
};

var keys = Object.keys(Person.prototype);
alert(keys); //"name,age,job,sayName"

var p1 = new Person();
p1.name = 'Rob';
p1.age = 31;
var p1keys = Object.keys(p1);
alert(p1keys); //"name,age"
```

3. 更简单的原型语法

更简单的原型语法,字面量形式，实际上重写了原型对象，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的任然是最初的原型。
```
Person.prototype = {
    name : 'Nicholas',
    age : 29,
    job : 'Software Engineer',
    sayName : function() {
        alert(this.name);
    }
};
```
4. 原型的动态性

实例中的指针仅指向原型对象，而不指向构造函数。

重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。

5. 原型对象的问题

```
function Person() {    
}

Person.prototype = {
    constructor : Person,
    name : 'Nicholas',
    age : 29,
    job : 'Software Engineer',
    friends : ['Shelby','Court'],
    sayName : function() {
        alert(this.name);
    }
};

var person1 = new Person();
var person2 = new Person();

person1.friends.push('Van');

alert(person1.friends); //"Shelby,Court,Van"
alert(person2.friends); //"Shelby,Court,Van"
alert(person1.friends === person2.friends); //true
```
> 1. 省略了为构造函数传递初始化参数这一环节，所有实例默认情况下都取得相同的属性值
> 2. 原型中的所有属性被很多实例共享，由于friends数组存在于Person.prototype而非person1中，所以person1的push('Van')在person2中也会反映出来

实例上访问原型对象的属性，如果是引用类型的属性比如数组，实例上访问的是该数组的引用，任何操作都会发生改变

**4. 组合使用构造函数模式和原型模式**
```
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ['Shelby', 'Court']
}

Person.prototype = {
    constructor : Person,
    sayName : function() {
        alert(this.name);
    }
}

var person1 = new Person('Nicholas', 29, 'Software Engineer');
var person2 = new Person('Greg', 27, 'Doctor')

person1.friends.push('Van');
alert(person1.friends); //"Shelby,Count,Van"
alert(person2.friends); //"Shelby,Count"
alert(person1.friends === person2.friends); //false
alert(person1.sayName === person2.sayName); //true
```
使用构造函数就是在实例上创建构造函数中的属性

**5.动态原型模式**
将所有信息都封装在构造函数中，在构造函数中初始化原型
```
function Person() {

    //属性
    this.name = name;
    this.age = age;
    this.job = job;

    //方法
    if (typeof this.sayName != 'function') {

        Person.prototype.sayName = function() {
            alert(this.name);
        };
    }
}
```
**6.寄生构造函数模式**

寄生的意思就是增强创建出来的对象

基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。除了使用`new`操作符以外，这个模式与工厂模式其实是一模一样的。构造函数在不返回值得情况下，默认会返回新对象实例。通过在构造函数的末尾添加一个`return`语句，可以重写调用构造函数时返回的值。

假设我们想创建一个具有额外方法的特殊数组，由于不能直接修改`Array`构造函数，因此使用这个模式。
```
function SpecialArray() {

    //创建数组
    var values = new Array();

    //添加值
    values.push.apply(values, arguments);

    //添加方法
    values.toPipedString = function() {
        return this.join('|');
    };

    //返回数组
    return values;
}

var colors = new SpecialArray('red', 'blue', 'green');
alert(colors.toPipedString()); //"red|blue|green"
```


### 继承

许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，依靠原型链实现。

**1. 原型链继承**
```
function SuperType() {
    this.property = true;
}

SuperType.prototype.getSuperValue = function() {
    return this.perperty;
};

function SubType() {
    this.subproperty = false;
}

//继承了SuperType
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function() {
    return this.subproperty;
}

var instance = new SubType();
alert(instance.getSuperValue()); //true
```
> 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象

原型链继承的本质是重写原型对象，代之以一个新类型的实例

所有的函数的默认原型都是Object的实例，因此默认原型会包含一个内部指针，指向Object.prototype

确定原型和实例的关系`instanceof`操作符，`isPrototypeOf()`方法。
```
alert(instance instanceof Object);
alert(Object.prototype.isPrototypeOf(instance));
```

给原型添加方法的代码一定要放在替换原型的语句之后

原型链的问题
```
function SuperType() {
    this.colors = ['red', 'blue', 'green'];
}

function SubType() {
}

//继承了 SuperType
SubType.prototype = new SuperType();

var instance1 = new SubType();
instance1.colors.push('black');
alert(instance1.colors); //"red,blue,green,black"

var instance2 = new SubType();
alert(instance2.colors); //"red,blue,green,black"
```
原先的实例属性变成了现在的原型属性，不能向超类型的构造函数中传递参数

**2. 借用构造函数**
```
function SuperType() {
}

function SubType() {
    //继承了SuperType
    SuperType.call(this);
}

var instance1 = new SubType();
instance1.colors.push('black');
alert(instance1.colors); //"red,blue,green,black"

var instance2 = new SubType();
alert(instance2.colors); //"red,blue,green"
```
call和apply是为了动态改变this而出现的，当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。

实际上是在将要创建的SubType实例环境中调用了SuperType构造函数，这样一来就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。这样SubType每个实例就会有自己colors属性副本了。

借用构造函数还可以传递参数
```
function SuperType(name) {
    this.name = name;
}

function SubType() {
    //继承了SuperType,同时还传递了参数
    SuperType.call(this,'Nicholas');

    //实例属性  
    this.age = 29;
}

var instance = new SubType();
alert(instance.name); //"Nicholas";
alert(instance.age); //29

var instance1 = new SubType();
alert(instance1.age);
```
借用构造函数的问题：方法都在构造函数中，做不到函数复用。

**3. 组合继承**

背后的思路是使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。

在原型上定义方法实现函数复用，又保证每个实例都有自己的属性。

```
function SuperType(name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

SuperType.prototype.sayName = function() {
    alert(this.name);
}

function SubType(name,age) {
    //继承属性
    SuperType.call(this,name);
    this.age = age;
}

SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function() {
    alert(this.age);
};

var instance1 = new SubType('Nicholas','29');
instance1.colors.push('black');
alert(instance1.colors); //"red,blue,green,black"
instance1.sayName(); //"Nicholas"
instance1.sayAge(); //29

var instance2 = new SubType('Greg','27');
alert(instance2.colors); //"red,blue,green"
instance2.sayName(); //"Greg"
instance2.sayAge(); //27
```

**4.原型式继承**

```
function object(o) {
    function F() {};
    F.prototype = o;
    return new F();
}
```

```
var person = {
    name: 'Nicholas',
    friend: ['Shelby', 'Court', 'Van']
};

var anotherPerson = object(person);
anotherPerson.name = 'Greg';
anotherPerson.friends.push('Rob');

var yetAnotherPerson = object(person);
yetAnotherPerson.name = 'Linda';
yetAnotherPerson.friends.push('Barbie');

alert(person.friends); //"Shelby,Court,Van,Rob,Barbie"
```

ECMAscript5新增`Object.create()`方法规范了原型式继承。传入一个参数的情况下，`Object.create()`与`object()`方法行为相同。
```
var person = {
    name: 'Nicholas',
    friend: ['Shelby', 'Court', 'Van']
};

var anotherPerson = Object.create(person);
anotherPerson.name = 'Greg';
anotherPerson.friends.push('Rob');

var yetAnotherPerson = Object.create(person);
yetAnotherPerson.name = 'Linda';
yetAnotherPerson.friends.push('Barbie');

alert(person.friends); //"Shelby,Court,Van,Rob,Barbie"
```
`Object.create()`方法第二个参数与`Object.defineProperties()`第二个参数格式相同。

**5.寄生式继承**
```
function createAnother(original) {
    var clone = object(original); //通过调用函数创建一个新对象
    clone.sayHi = function() { //以某种方式来增强这个对象
        alert('hi');
    };
    return clone; //返回这个对象
}
```

```
var person = {
    name: 'Nicholas',
    friends: ['Shelby', 'Court', 'Van']
};

var anotherPerson = createAnother(person);
anotherPrson.sayHi(); //"hi"
```

> 使用寄生式继承做不到函数复用，效率不高

**6.寄生组合式继承**

组合继承的不足在于，无论什么情况下，都会调用两次超类型构造函数

寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。不必为了指定子类型的原型而调用超类型构造函数。

```
function inheritPrototype(subType, superType) {
    var prototype = object(superType.prototype); //创建对象，返回的是superType.prototype的实例
    prototype.constructor = subType; //增强对象
    subType.prototype = prototype; //指定对象
}
```

```
function SuperType(name) {
    this.name = name;
    this.color = ['red', 'blue', 'green'];
}

SuperType.prototype.sayName = function() {
    alert(this.name);
};

function SubType(name, age) {
    SuperType.call(this, name);

    this.age = age;
}

inheritPrototype(SubType, SuperType);

SubType.ptototype.sayAge = funciton() {
    alert(this.age);
};
```
这种方式的高效在于只调用了一次`SuperType`构造函数，因此避免了在`SubType.prorotype`上面创建不必要的、多余的属性。与此同时，原型链还能保持不变。

### 总结
#### 创建对象的模式
1. 工厂模式

在函数中创建对象，为对象添加属性和方法，然后return这个对象。

2. 构造函数模式

创建自定义引用类型，使用new操作符。缺点是每个成员无法得到复用，包括函数。

3. 原型模式

使用构造函数的`prototype`属性来指定那些共享的属性和方法。组合使用构造函数模式和原型模式，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。

#### 继承
使用最多的继承模式式组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。

1. 原型式继承

本质是执行对给定对象的浅复制

2. 寄生式继承

与原型式继承非常相似，复制对象之后进行增强对象的操作

3. 寄生组合式继承

集寄生式继承和组合继承的有点于一身，解决了组合继承模式由于多次调用超类型构造函数而导致的低效率问题